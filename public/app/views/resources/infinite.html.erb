<a name="main" title="<%= t('internal_links.main') %>"></a>

<div id="main-content" class="row">
  <div class="information col-sm-7">
    <%= render partial: 'shared/idbadge', locals: {:result => @result, :props => { :full => true} } %>
  </div>
  <div class="page_actions col-sm-5 right">
    <%= render partial: 'shared/page_actions', locals: {:record => @result, :title =>  @result.display_string, :url => request.fullpath, :cite => @result.cite } %>
  </div>
</div>

<div class="row">
  <%= render partial: 'shared/breadcrumbs' %>
</div>

<%= render partial: 'resources/resource_alltabs' %>

<%
  content_waypoint_size = 20
  sidebar_waypoint_size = 200
  num_records = @ordered_records.count
%>
<div class="row">
  <div class="col-sm-9 records-progress-container">
    <p class="records-progress-label">
      <span style="padding: .15rem;" data-showing-current>&nbsp;&nbsp;&nbsp;</span>
      of
      <span style="padding: .15rem;" data-showing-total><%= num_records %></span>
      records in this collection have loaded onto the page below so far. Scroll down to load more, or click the <strong>&nbsp;Load all records&nbsp;</strong> button.
    </p>
    <button class="btn btn-primary records-progress-button" data-show-all-records>Load all records</button>
  </div>
  <div class="col-sm-3">
  </div>
</div>

<div class="row" style="overflow: hidden;">
  <div
    class="infinite-scroll-container col-sm-9"
    data-waypoint-size="<%= content_waypoint_size %>"
    data-total-records="<%= num_records %>">
    <div class="root">
      <% @ordered_records.each_slice(content_waypoint_size).each_with_index do |refs, i| %>
        <div
          class="waypoint"
          data-waypoint-number="<%= i %>"
          data-uris="<%= refs.map {|r| r['ref']}.join(';') %>"
        >&nbsp;</div>
      <% end %>
    </div>
  </div>
  <div id="sidebar" class="sidebar sidebar-container col-sm-3 resizable-sidebar infinite-tree-sidebar">
    <% if AppConfig[:pui_search_collection_from_collection_organization] %>
      <%= render partial: 'shared/search_collection_form', :locals => {:resource_uri => @result['uri'], :action_text => t('actions.search_in', :type => t('resource._singular'))} %>
    <% end %>

    <div
      class="infinite-tree-view largetree-container"
      id="tree-container"
      data-waypoint-size="<%= sidebar_waypoint_size %>"
      data-repo-id="<%= @result['uri'].split('/')[2] %>"
      data-resource-id="<%= @result['uri'].split('/')[4] %>"
    >
    </div>
  </div>
</div>

<dialog data-loading-modal>
  <div class="spinner-border" role="status">
    <span class="visually-hidden">Loading...</span>
  </div>
</dialog>

<template id="root-row-template">
  <div id="" class="table-row root-row" role="listitem" data-uri="">
    <div class="table-cell title">
      <a class="record-title" href=""></a>
    </div>
  </div>
</template>

<template id="node-row-template">
  <div id="" class="table-row largetree-node" role="listitem" data-uri="">
    <div class="table-cell title" title="">
      <span class="indentor">
        <button class="expandme" aria-expanded="false">
          <i class="expandme-icon glyphicon glyphicon-chevron-right"></i>
          <span class="sr-only"></span>
        </button>
      </span>
      <a class="record-title" href=""></a>
    </div>
  </div>
</template>

<template id="infinite-record-record-template">
  <div
    class="infinite-record-record"
    id
    data-uri
    data-record-number
    data-observe
  ></div>
</template>

<script>
  $(document).ready(function () {
    // nav infinite scroll

    const NAV_WAYPOINT_SIZE = '<%= sidebar_waypoint_size %>';
    const repoId = '<%= @result['uri'].split('/')[2] %>';
    const resourceId = '<%= @result['uri'].split('/')[4] %>';
    const rootNodeDivId = `resource_${resourceId}`;
    const apiBase = '<%= url_for(:action => :show) %>';
    const treeBaseUri = `${apiBase}/tree`;
    const treeRootUri = `${treeBaseUri}/root`;
    const treeNodeUri = `${treeBaseUri}/node`;
    const treeWaypointUri = `${treeBaseUri}/waypoint`;

    const treeContainer = document.querySelector('#tree-container');

    const treeObsOpts = {
      root: treeContainer,
      rootMargin: '-30% 0px -30% 0px'
    };
    const treeWpObs = new IntersectionObserver(treeObsHandler, treeObsOpts);

    fetchRootNode()
      .done(rootNode => {
        const aHref = `#tree::resource_${resourceId}`;
        const title = rootNode.title;
        const identifier = rootNode.identifier;
        const firstWPData = rootNode.precomputed_waypoints[""][0];

        const tableRootFrag = new DocumentFragment();

        const tableRoot = document.createElement('div');
        tableRoot.setAttribute('role', 'list');
        tableRoot.className = 'table root';

        tableRoot.appendChild(rootRowMarkup(nodeTitle(rootNode)));
        tableRoot.appendChild(rootNodeWaypointsScaffold(
          rootNodeDivId,
          1,
          rootNode.waypoints
        ));

        __populateWaypoint(
          tableRoot.querySelector('.table-row-group'),
          firstWPData,
          1,
          rootNode.waypoints > 1
        );

        tableRootFrag.appendChild(tableRoot);

        treeContainer.appendChild(tableRootFrag);

        if (rootNode.waypoints > 1) {
          // now that the above work has been added to the live DOM, start observing
          // the middle node in order to populate the next empty waypoint
          const obsSelector = `[data-parent-id="${rootNodeDivId}"][data-waypoint-number="0"] > [data-observe-next-wp]`;
          const obsTarget = document.querySelector(obsSelector);

          treeWpObs.observe(obsTarget);
        }
      })
      .fail(err => {
        console.log('root node fetch error: ', err);
      });
    
    $('#tree-container').on('click', '.expandme', function(e){
      this.setAttribute('aria-expanded', this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true');
      $(this).closest('.largetree-node').attr('data-is-expanded', this.getAttribute('aria-expanded'));
      $(this).find('.expandme-icon').toggleClass('expanded');

      if (this.closest('.largetree-node').getAttribute('data-has-expanded') === 'false') {
        const nodeDivId = this.closest('.largetree-node').id;

        initNodeChildren(nodeDivId);

        this.closest('.largetree-node').setAttribute('data-has-expanded', true);
      }
    });

    /**
     * __populateWaypoint
     * @description - Populate the first waypoint of a newly created
     * rootNodeWaypointsScaffold
     * @param {HTMLElement} waypoint - the empty waypoint to populate
     * @param {array} nodes - array of node objects to populate the waypoint with
     * @param {number} level - level of the waypoint
     * @param {boolean} hasNextEmptyWP - whether or not there is a next empty waypoint
     */
    function __populateWaypoint(waypoint, nodes, level, hasNextEmptyWP) {
      const waypointMarker = waypoint.querySelector('.waypoint');
      const nodeRowsFrag = new DocumentFragment();

      waypointMarker.classList.add('populated');

      nodes.forEach((node, i) => {
        // observe the middle node if there is a next empty waypoint
        const observeThisNode = (i == Math.floor(NAV_WAYPOINT_SIZE / 2) - 1 && hasNextEmptyWP);
        const markupArgs = [node, level, observeThisNode];

        if (observeThisNode) {
          const nodeParentId = waypoint.getAttribute('data-parent-id');
          const nodeWpNum = parseInt(waypoint.getAttribute('data-waypoint-number'), 10);

          markupArgs.push(nodeParentId, nodeWpNum + 1);
        }

        nodeRowsFrag.appendChild(nodeRowMarkup(...markupArgs));
      });

      waypoint.appendChild(nodeRowsFrag);
    }

    /**
     * nodeWaypointsScaffold
     * @description - Append the empty set of waypoint containers belonging to a node
     * after the node element; append elements manually because insertAdjacentElement()
     * @param {number} nodeId - div id of the parent node whose waypoints
     * are being scaffolded
     * @param {number} level - level of the waypoints
     * @param {number} numWPs - number of waypoints to create
     */
    function nodeWaypointsScaffold(nodeId, level, numWPs) {
      for (let i = 0; i < numWPs; i++) {
        const prevSibling = i === 0
          ? document.querySelector(`#${nodeId}`)
          : document.querySelector(`[data-parent-id="${nodeId}"][data-waypoint-number="${i - 1}"]`);

        const tableRowGroup = document.createElement('div');
        tableRowGroup.className = 'table-row-group';
        tableRowGroup.setAttribute('data-parent-id', nodeId);
        tableRowGroup.setAttribute('data-waypoint-number', i);
        tableRowGroup.setAttribute('data-waypoint-level', level);
        tableRowGroup.setAttribute('role', 'list');

        const tableRow = document.createElement('div');
        tableRow.className = `table-row waypoint indent-level-${level}`;

        prevSibling.insertAdjacentElement('afterend', tableRowGroup);

        const liveTableRowGroup = document.querySelector(
          `[data-parent-id="${nodeId}"][data-waypoint-number="${i}"]`
        );

        liveTableRowGroup.appendChild(tableRow);
      }
    }

    /**
     * rootNodeWaypointsScaffold
     * @description - Build the waypoints of a node and populate the first waypoint
     * @param {number} nodeId - div id of the parent node whose waypoints
     * are being scaffolded
     * @param {number} level - level of the waypoints
     * @param {number} numWPs - number of waypoints to create
     * @returns {DocumentFragment} - DocumentFragment containing the waypoint
     */
    function rootNodeWaypointsScaffold(nodeId, level, numWPs) {
      const nodeWaypointsFrag = new DocumentFragment();

      for (let i = 0; i < numWPs; i++) {
        const tableRowGroup = document.createElement('div');
        tableRowGroup.className = 'table-row-group';
        tableRowGroup.setAttribute('data-parent-id', nodeId);
        tableRowGroup.setAttribute('data-waypoint-number', i);
        tableRowGroup.setAttribute('data-waypoint-level', level);
        tableRowGroup.setAttribute('role', 'list');

        const tableRow = document.createElement('div');
        tableRow.className = `table-row waypoint indent-level-${level}`;

        tableRowGroup.appendChild(tableRow);

        nodeWaypointsFrag.appendChild(tableRowGroup);
      }

      return nodeWaypointsFrag;
    }

    /**
     * nodeRowMarkup
     * @description - Build the markup for a node row
     * @param {Object} node - node data
     * @param {number} level - indent level of the node
     * @param {boolean} shouldObserve - whether or not to observe the node
     * in order to populate the next empty waypoint
     * @param {number} [parentId=null] - optional ID of the node's parent; if null
     * then parent is assumed to be the root resource
     * @param {number} [offset=null] - optional offset of the next waypoint to
     * populate; required if `shouldObserve` is true
     * @returns {DocumentFragment} - DocumentFragment containing the node row
     */
    function nodeRowMarkup(node, level, shouldObserve, parentId = null, offset = null) {
      const aoId = node.uri.split('/')[4];
      const divId = `archival_object_${aoId}`;
      const aoTitle = nodeTitle(node);
      const aHref = `#tree::${divId}`;

      const nodeRowFrag = new DocumentFragment();

      const nodeRow = document.querySelector('#node-row-template').content.cloneNode(true);

      nodeRow.querySelector('.table-row').id = divId;
      nodeRow.querySelector('.table-row').classList.add(`indent-level-${level}`);
      nodeRow.querySelector('.table-row').setAttribute('data-uri', node.uri);

      if (shouldObserve) {
        const nodeParam = parentId.startsWith('resource')
          ? ''
          : `/repositories/${repoId}/archival_objects/${parentId.split('_')[2]}`;

        nodeRow.querySelector('.table-row').setAttribute('data-observe-next-wp', true);
        nodeRow.querySelector('.table-row').setAttribute('data-observe-node', nodeParam);
        nodeRow.querySelector('.table-row').setAttribute('data-observe-offset', offset);
      }

      nodeRow.querySelector('.title').setAttribute('title', aoTitle);

      if (node.child_count == 0) {
        nodeRow.querySelector('.expandme').style.visibility = 'hidden';
        nodeRow.querySelector('.expandme').setAttribute('aria-hidden', 'true');
      } else if (node.child_count > 0) {
        nodeRow.querySelector('.table-row').setAttribute('data-has-expanded', false)
        nodeRow.querySelector('.table-row').setAttribute('data-is-expanded', false)
        nodeRow.querySelector('.expandme').setAttribute('aria-expanded', 'false');
      }

      nodeRow.querySelector('.sr-only').textContent = aoTitle;

      if (node.has_digital_instance) {
        const iconHtml = `<i class="has_digital_instance fa fa-file-image-o" aria-hidden="true"></i>`;
        nodeRow.querySelector('.record-title').insertAdjacentHTML('beforebegin', iconHtml);
      }

      nodeRow.querySelector('.record-title').setAttribute('href', aHref);
      nodeRow.querySelector('.record-title').textContent = aoTitle;

      nodeRowFrag.appendChild(nodeRow);

      return nodeRowFrag;
    }

    /**
     * nodeTitle
     * @description - Build the title of a node
     * @param {Object} node - node data
     * @returns {string} - title of the node
     */
    function nodeTitle(node) {
      const title = [];

      if (SHOW_IDENTIFIERS_IN_TREE && node.identifier && node.parsed_title) {
        const sep = '<%= I18n.t('resource.identifier_separator') %>';
        title.push(`${node.identifier}${sep} ${node.parsed_title}`);
      } else if (node.parsed_title) {
        title.push(node.parsed_title);
      }

      if (node.label) {
        title.push(node.label);
      }

      if (node.dates && node.dates.length > 0) {
        node.dates.forEach(function(date) {
          if (date.expression) {
            if (date.type === 'bulk') {
              title.push('<%= I18n.t("date_type_bulk.bulk") %>: ' + date.expression);
            } else {
              title.push(date.expression);
            }
          } else if (date.begin && date.end) {
            if (date.type === 'bulk') {
              title.push('<%= I18n.t("date_type_bulk.bulk") %>: ' + date.begin + '-' + date.end);
            } else {
              title.push(date.begin + '-' + date.end);
            };
          } else if (date.begin) {
            if (date.type === 'bulk') {
              title.push('<%= I18n.t("date_type_bulk.bulk") %>: ' + date.begin);
            } else {
              title.push(date.begin);
            };
          }
        })
      }

      return title.join(', ');
    }

    /**
     * rootRowMarkup
     * @description Append the root row to the tree container
     * @param {string} title - title of the root node
     * @returns {DocumentFragment} - DocumentFragment containing the root row
     */
    function rootRowMarkup(title) {
      const rootRowFrag = new DocumentFragment();
      const rootRow = document.querySelector('#root-row-template').content.cloneNode(true);
      const uri = `/repositories/${repoId}/resources/${resourceId}`;

      rootRow.querySelector('.table-row').id = `resource_${resourceId}`
      rootRow.querySelector('.table-row').setAttribute('data-uri', uri);

      rootRow.querySelector('.record-title').href = `#tree::resource_${resourceId}`;
      rootRow.querySelector('.record-title').innerHTML = title;

      rootRowFrag.appendChild(rootRow);

      return rootRowFrag;
    }

    /**
     * fetchWaypoint
     * @description Fetch the next waypoint of the given node
     * @param {Object} params - object of params for the ajax call with the signature:
     * @param {string} params.node - node url param in the form of '' or '/repositories/X/archival_objects/Y'
     * @param {number} params.offset - offset url param
     * @returns {Promise} - Promise that resolves with the waypoint object
     */
    function fetchWaypoint(params) {
      return $.ajax(treeWaypointUri, {
        method: 'GET',
        dataType: 'json',
        data: params
      });
    }

    /**
     * fetchNode
     * @description Fetch the tree of the node with the given id
     * @param {number} nodeId - id of the node, ie: 18028
     * @returns {Promise} - Promise that resolves with the node object
     */
    function fetchNode(nodeId) {
      return $.ajax(treeNodeUri, {
        method: 'GET',
        dataType: 'json',
        data: {
          node: `/repositories/${repoId}/archival_objects/${nodeId}`
        }
      });
    }

    /**
     * fetchRootNode
     * @description Fetch the root node of the tree
     * @returns {Promise} - Promise that resolves with the root node object
     */
    function fetchRootNode() {
      return $.ajax(treeRootUri, { method: "GET", dataType: 'json' });
    }

    function treeObsHandler(entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const thisWaypoint = entry.target.closest('.table-row-group');

          if (!nextSiblingIsNextWaypoint(thisWaypoint)) {
            return;
          }

          const nextWaypoint = thisWaypoint.nextElementSibling;
          const node = entry.target.getAttribute('data-observe-node');
          const offset = entry.target.getAttribute('data-observe-offset');
          const level = thisWaypoint.getAttribute('data-waypoint-level');

          fetchWaypoint({ node, offset})
            .done((nodes) => {
              const nextWPHasNextWP = nextSiblingIsNextWaypoint(nextWaypoint);

              __populateWaypoint(nextWaypoint, nodes, level, nextWPHasNextWP);

              if (nextWPHasNextWP) {
                const nextWPTarget = nextWaypoint.querySelector('[data-observe-next-wp="true"]');

                observer.observe(nextWPTarget);
              }

              entry.target.removeAttribute('data-observe-next-wp');
              entry.target.removeAttribute('data-observe-node');
              entry.target.removeAttribute('data-observe-offset');

              observer.unobserve(entry.target);
            })
        }
      })
    };

    /**
     * nextSiblingIsNextWaypoint
     * @description Determine if the next sibling of the given waypoint is
     * the next empty waypoint of the same parent
     * @param {HTMLElement} waypoint - waypoint to check
     * @returns {boolean} - true if the next sibling is the next empty waypoint
     * of the same parent
     */
    function nextSiblingIsNextWaypoint(waypoint) {
      const nextSibling = waypoint.nextElementSibling;

      if (!nextSibling) {
        return false;
      }

      const thisWpParent = waypoint.getAttribute('data-parent-id');
      const thisWpNum = parseInt(waypoint.getAttribute('data-waypoint-number'), 10);

      const nextSiblingParent = nextSibling.getAttribute('data-parent-id');
      const nextSiblingWpNum = parseInt(nextSibling.getAttribute('data-waypoint-number'), 10);
      const nextSiblingFirstChild = nextSibling.firstElementChild;

      return nextSiblingParent == thisWpParent &&
        nextSiblingWpNum == thisWpNum + 1 &&
        nextSiblingFirstChild.classList.contains('waypoint') &&
        !nextSiblingFirstChild.classList.contains('populated');
    };

    /**
     * initNodeChildren
     * @description Build a parent node's waypoint scaffold and populate the first
     * waypoint
     * @param {string} nodeDivId - div#id of the parent node, ie: 'archival_object_18028'
     */
    function initNodeChildren(nodeDivId) {
      const parentNode = document.querySelector(`#${nodeDivId}`);
      const nodeId = nodeDivId.split('_')[2];
      const nodeLevel = parseInt(document
        .querySelector(`#${nodeDivId}`)
        .closest('.table-row-group')
        .getAttribute('data-waypoint-level'), 10);

      fetchNode(nodeId)
        .done((node) => {
          const nodeWpCount = node.waypoints;
          const nodeUri = `/repositories/${repoId}/archival_objects/${nodeId}`;

          nodeWaypointsScaffold(nodeDivId, nodeLevel + 1, nodeWpCount);

          const firstWP = document.querySelector(`[data-parent-id="${nodeDivId}"][data-waypoint-number="0"]`);

          __populateWaypoint(
            firstWP,
            node.precomputed_waypoints[nodeUri][0],
            nodeLevel + 1,
            nodeWpCount > 1
          );

          if (nodeWpCount > 1) {
            treeWpObs.observe(firstWP.querySelector('[data-observe-next-wp]'));
          }
        });
    }


    // content infinite scroll
    const WAYPOINT_SIZE = parseInt($('.infinite-scroll-container').data('waypoint-size'), 10);
    const NUM_TOTAL_RECORDS = parseInt($('.infinite-scroll-container').data('total-records'), 10);
    const NUM_TOTAL_WAYPOINTS = Math.ceil(NUM_TOTAL_RECORDS / WAYPOINT_SIZE);
    const contentScrollContainer = document.querySelector('.infinite-scroll-container');
    const modal = document.querySelector('[data-loading-modal]');
    const recordsWaypointUri = `${apiBase}/infinite/waypoints`;

    /**
     * __renderWaypoints
     * @description - Render the given waypoints
     * @param {number[]} wpNums - array of waypoint numbers to render
     * @param {string|null} [scrollToRecordUri=null] - uri of the record
     * to scroll to after the waypoints have been rendered, default null
     */
    async function __renderWaypoints(wpNums, scrollToRecordUri = null) {
      isOkToObserve = false;
      
      toggleModal();

      const data = await _fetchWaypoints(wpNums);

      __populateRecordWaypoints(data);

      considerEmptyNeighbors(wpNums);

      if (scrollToRecordUri !== null) {
        const targetRecord = document
          .querySelector(`.infinite-record-record[data-uri="${scrollToRecordUri}"]`);

        targetRecord.scrollIntoView({ behavior: 'smooth' });
      }

      // Safari scroll bugs surface majorly when the next line is uncommented
      // if (!scrollToRecordUri) isOkToObserve = true;

      toggleModal();
    }

    function recordsWaypointScrollHandler(entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting && isOkToObserve) {
          const emptyWaypointNums = entry.target.dataset.observeForWaypoints;
          const observingTargets = document.querySelectorAll(
            `[data-observe-for-waypoints="${emptyWaypointNums}"]`
          );

          __renderWaypoints(JSON.parse(emptyWaypointNums));

          observingTargets.forEach((target) => {
            target.removeAttribute('data-observe-for-waypoints');

            observer.unobserve(target);
          });
        }
      });
    };

    const recordsWPObs = new IntersectionObserver(recordsWaypointScrollHandler, {
      root: contentScrollContainer,
      rootMargin: '0px 0px 0px 0px'
    });

    function contentRecordScrollHandler(entries, observer) {
      entries.forEach((entry, i) => {
        if (entry.isIntersecting) {
          const uri = entry.target.dataset.uri;
          const _new = document.querySelector(`#tree-container .table-row[data-uri="${uri}"]`);
          const old = document.querySelector('#tree-container .table-row.current')

          if (old) {
            old.classList.remove('current');
          }

          _new.classList.add('current');
        }
      });
    };

    const contentRecordObs = new IntersectionObserver(contentRecordScrollHandler, {
      root: document.querySelector('.infinite-scroll-container'),
      rootMargin: '-5px 0px -95% 0px' // only the top sliver
    });

    let isOkToObserve = true;

    contentScrollContainer.addEventListener(
      'scrollend',
      () => {
        isOkToObserve = true;
      }
    );


    initRecords(window.location.hash);

    /**
     * initRecords
     * @description - Append one or more waypoints to the DOM depending
     * on window.location.hash
     * @param {Location} hash - Location hash string
     */
    async function initRecords(hash) {
      const initialWaypoints = [];
      let initialData;

      if (hash === "") {
        initialWaypoints.push(0);

        if (NUM_TOTAL_WAYPOINTS > 1) initialWaypoints.push(1);

        __renderWaypoints(initialWaypoints);
      } else {
        // there is a hash, so let's scroll to that record, but first we have
        // to get the waypoint numbers of the record and any of its WP neighbors
        // we get the record by parsing the hash, then we get its waypoint number.
        // then we check if there are empty neighbors before and after this waypoint.
        // 
        const recordUri = treeIdToRecordUri(hash);
        const recordWaypointNum = treeIdtoWaypointNumber(hash);

        initialWaypoints.push(recordWaypointNum);

        if (hasEmptyPrevWP(recordWaypointNum)) {
          initialWaypoints.push(recordWaypointNum - 1);
        }

        if (hasEmptyNextWP(recordWaypointNum)) {
          initialWaypoints.push(recordWaypointNum + 1);
        }

        __renderWaypoints(initialWaypoints, recordUri);
      }
    }

    // need to set isOkToObserve = false, then remove the event listener
    // so let's start by rewriting the below jquery using vanilla js
    // $('[data-show-all-records]').on('click', () => { populateAllWaypoints(); });

    const showAllRecordsBtn = document.querySelector('[data-show-all-records]');
    showAllRecordsBtn.addEventListener('click', populateAllWaypoints);

    $('#tree-container').on('click', 'a.record-title', largetreeLinkClickHandler);

    /**
     * largetreeLinkClickHandler
     * @description - Handle click events on record titles in the tree by
     * scrolling to the record if it exists, or rendering the record's
     * waypoint and nearby waypoints then scrolling to the record
     * @param {Event} event - click event
     */
    async function largetreeLinkClickHandler(event) {
      event.preventDefault();

      const targetDivId = this.href.split('#')[1];
      const recordUri = treeIdToRecordUri(targetDivId);

      const recordSelector = `.infinite-record-record[data-uri='${recordUri}']`;
      const scrollOpts = { behavior: 'smooth' };

      window.location.hash = targetDivId;

      const record = document.querySelector(recordSelector);

      if (record) {
        record.scrollIntoView(scrollOpts);
      } else {
        // Record doesn't exist so render its waypoint and any
        // empty neighbors, then scroll to the record
        const recordWaypointNum = treeIdtoWaypointNumber(targetDivId);
        const newWaypoints = [recordWaypointNum];

        if (hasEmptyPrevWP(recordWaypointNum)) {
          newWaypoints.push(recordWaypointNum - 1);
        }

        if (hasEmptyNextWP(recordWaypointNum)) {
          newWaypoints.push(recordWaypointNum + 1);
        }

        __renderWaypoints(newWaypoints, recordUri);
      }
    }     

    /**
     * considerEmptyNeighbors
     * @description - Conditionally set the `data-observe-for-waypoints` 
     * attribute on all records in a given waypoint with an empty neighbor
     * (the values of which are a stringified array of waypoint numbers of 
     * the empty neighbors), and start observing each record to populate
     * nearby empty waypoints
     * @param {number[]} wpNums - array of waypoint numbers to consider
     */
    function considerEmptyNeighbors(wpNums) {
      wpNums.forEach((wpNum) => {
        const waypoint = document
          .querySelector(`.waypoint.populated[data-waypoint-number='${wpNum}']`);

        if (!waypoint) {
          return;
        }

        const empties = [];

        if (hasEmptyPrevWP(wpNum)) {
          empties.push(wpNum - 1);

          // When scrolling up watch for the previous empty waypoint's
          // previous empty waypoint too to (hopefully) avoid missed 
          // observations from fast scrolling (mostly in Safari)
          if (hasEmptyPrevWP(wpNum - 1)) {
            empties.push(wpNum - 2);
          }
        }

        if (hasEmptyNextWP(wpNum)) {
          empties.push(wpNum + 1);
        }

        if (empties.length > 0) {
          const records = waypoint.querySelectorAll('.infinite-record-record');

          records.forEach((record) => {
            record
              .setAttribute('data-observe-for-waypoints', JSON.stringify(empties));

            recordsWPObs.observe(record);
          });
        }
      });
    }

    /**
     * clearWaypointFromDatasets
     * @description - Remove a waypoint number from all record data attributes
     * that include the waypoint number; remove the records's data attribute
     * entirely if the waypoint number is the only item in the attribute's value
     */
    function clearWaypointFromDatasets(wpNum) {
      const potentialRecords = document.querySelectorAll(
        `.infinite-record-record[data-observe-for-waypoints*='${wpNum}']`
      );
      const records = Array.from(potentialRecords).filter((record) => {
        const wpNums = JSON.parse(record.dataset.observeForWaypoints);

        return wpNums.includes(wpNum);
      });

      records.forEach((record) => {
        const wpNums = JSON.parse(record.dataset.observeForWaypoints);
        const newWpNums = wpNums.filter((num) => num !== wpNum);

        if (newWpNums.length > 0) {
          record.dataset.observeForWaypoints = JSON.stringify(newWpNums);
        } else {
          record.removeAttribute('data-observe-for-waypoints');

          recordsWPObs.unobserve(record);
        }
      });
    }

    /**
     * _fetchWaypoints
     * @description Fetch one or more waypoints of records
     * @param {number[]} wpNums - array of the waypoint numbers to fetch
     * @returns {Promise} - A Promise that resolves to an array of waypoint
     * objects, each with the signature: `{ wpNum, records }`
     */
    async function _fetchWaypoints(wpNums) {
      console.log('wpNums::::::::::', wpNums)
      if (wpNums.length === 1) {
        console.log('_fetchWaypoint(wpNums[0])::::::::::', await _fetchWaypoint(wpNums[0]));
        return [await _fetchWaypoint(wpNums[0])];
      } else if (wpNums.length > 1) {
        const promises = [];

        wpNums.forEach((wpNum) => {
          promises.push(_fetchWaypoint(wpNum));
        });

        return Promise.all(promises)
          .then((responses) => {
            console.log('responses::::::::::', responses);
            return responses
          })
          .catch((err) => {
            console.error(err);
          });
      }
    }

    /**
     * _fetchWaypoint
     * @description Fetch a waypoint of records
     * @param {number} wpNum - the waypoint number to fetch
     * @returns {Promise} - Promise that resolves with the waypoint object made up of
     * keys of record uris and values of record markup
     */
    function _fetchWaypoint(wpNum) {
      const waypoint = document.querySelector(
        `.waypoint[data-waypoint-number='${wpNum}']:not(.populated)`
      );
      const query = new URLSearchParams();

      waypoint.dataset.uris.split(';').forEach((uri) => {
        query.append('urls[]', uri);
      });

      const url = `${recordsWaypointUri}?${query}`;

      return fetch(url)
        .then((response) => response.json())
        .then((records) => ({ wpNum, records }))
        .catch((err) => {
          console.error(err);
        })
    }

    /**
     * hasEmptyPrevWP
     * @description Determine if the waypoint before the given waypoint is empty
     * @param {number} wpNum - number of the waypoint with possible empty neighbor
     * @returns {boolean} - true if the waypoint before the given waypoint is empty
     */
    function hasEmptyPrevWP(wpNum) {
      return wpNum > 0
        ? !document
            .querySelector(`.waypoint[data-waypoint-number='${wpNum - 1}']`)
            .classList.contains('populated')
        : false;
    }

    /**
     * hasEmptyNextWP
     * @description Determine if the waypoint after the given waypoint is empty
     * @param {number} wpNum - number of the waypoint with possible empty neighbor
     * @returns {boolean} - true if the waypoint after the given waypoint is empty
     */
    function hasEmptyNextWP(wpNum) {
      return wpNum <= NUM_TOTAL_WAYPOINTS - 2
        ? !document
            .querySelector(`.waypoint[data-waypoint-number='${wpNum + 1}']`)
            .classList.contains('populated')
        : false;
    }

    /**
     * __populateRecordWaypoints
     * @description Append markup of records data to one or more waypoints,
     * start observing each record via `contentRecordObs`,
     * run `updateShowingCurrent()`, and clear the waypoint number(s) from any
     * record data attributes that include it
     * @param {Object[]} waypoints - array of waypoint objects as
     * returned from `fetchWaypoints()`, each of which represents one waypoint
     * with the signature: { wpNum, records}
     */
    function __populateRecordWaypoints(waypoints) {
      console.log('__populateRecordWaypoints waypoints: ', waypoints)
      waypoints.forEach((waypoint) => {
        const { wpNum, records } = waypoint;
        const waypointEl = document.querySelector(
          `.waypoint[data-waypoint-number='${wpNum}']:not(.populated)`
        );

        if (!waypointEl) {
          return;
        }

        const uris = waypointEl.dataset.uris.split(';');
        const recordsFrag = new DocumentFragment();

        uris.forEach((uri, i) => {
          const recordNumber = wpNum * WAYPOINT_SIZE + i;
          const type = uri.split('/')[3].replace(/s+$/, "");
          const id = uri.split('/')[4];
          const treeId = `tree::${type}_${id}`;
          const isEven = i > 0 && i % 2 === 0;
          const recordEl = document
            .querySelector('#infinite-record-record-template').content.cloneNode(true);

          recordEl.querySelector('div').id = treeId;
          recordEl.querySelector('div').setAttribute('data-uri', uri);
          recordEl.querySelector('div').setAttribute('data-observe', 'record');
          recordEl.querySelector('div').setAttribute('data-record-number', recordNumber);

          // The record container is all set up so inject ajax data
          recordEl.querySelector('div').insertAdjacentHTML('beforeend', records[uri]);

          recordsFrag.appendChild(recordEl);
        });

        waypointEl.appendChild(recordsFrag);

        // Watch the new records to highlight the current title in the largetree
        waypointEl.querySelectorAll('.infinite-record-record').forEach((record) => {
          contentRecordObs.observe(record);
        });

        waypointEl.classList.add('populated');

        clearWaypointFromDatasets(wpNum);

        updateShowingCurrent();
      });
    }

    /**
     * treeIdtoWaypointNumber
     * @description Get the waypoint number of the record with the given treeId
     * @param {string} treeId - treeId of the record with or without a leading '#'
     * eg: #tree::archival_object_123
     * @returns {number} - waypoint number
     */
    function treeIdtoWaypointNumber(treeId) {
      return parseInt(
        contentScrollContainer
          .querySelector(`.waypoint[data-uris*='${treeIdToRecordUri(treeId)}']`)
          .getAttribute('data-waypoint-number'),
        10
      );
    }

    /**
     * treeIdToRecordUri
     * @description Get the uri of a record given the treeId; useful since querying the DOM
     * for a string with `::` is messy.
     * @param {string} treeId - treeId of the record with or without a leading '#'
     * eg: #tree::archival_object_123
     * @returns {string} - record uri, e.g. /repositories/2/archival_objects/123
     */
    function treeIdToRecordUri(treeId) {
      const type = treeId.includes('resource')
        ? 'resources'
        : 'archival_objects';
      const id = treeId.split('_')[treeId.split('_').length - 1];

      return `/repositories/${repoId}/${type}/${id}`;
    }

    /**
     * toggleModal
     * @description Show spinner loading modal when fetching data
     */
    function toggleModal() {
      if (modal.open) {
        modal.close();
      } else {
        modal.showModal();
      }
    }

    // THIS WORKS, and works well. The large BYU resource is a real challenge for 
    // all browsers. Firefox works best, then safari although a bit clunky.
    // Chrome is totally messed up, erroring out on 400+ fetches from the worker
    // every time...not sure why. Perhaps splitting the total number of empty
    // waypoints to populate into slices of 20 or so, and run through each slice at
    // a time, sending data to the main thread before starting the next slice???
    /**
     * populateAllWaypoints
     * @description Populate remaining empty waypoints
     */
    function populateAllWaypoints() {
      const MAX_WAYPOINTS_MAIN_THREAD = 20;
      const resourceUri = `/repositories/${repoId}/resources/${resourceId}`;
      const waypointNums = Array
        .from(contentScrollContainer.querySelectorAll('.waypoint:not(.populated)'))
        .map(waypoint => parseInt(waypoint.dataset.waypointNumber, 10));      
      
      isOkToObserve = false;

      contentScrollContainer.removeEventListener(
        'scrollend',
        () => {
          isOkToObserve = true;
        }
      );

      toggleModal();
      
      if (waypointNums.length > 0 && waypointNums.length < MAX_WAYPOINTS_MAIN_THREAD) {
        __renderWaypoints(waypointNums);
      } else {
        const recordsWorker = new Worker("<%= javascript_path "worker_infinite.js" %>");
        const waypointTuples = waypointNums.map((wpNum) => [
            wpNum,
            contentScrollContainer
            .querySelector(`.waypoint[data-waypoint-number='${wpNum}']`)
            .dataset.uris.split(';')
          ]
        );

        recordsWorker.postMessage({ waypointTuples, resourceUri });

        recordsWorker.onmessage = (e) => {
          console.log('message event from worker: ', e);

          __populateRecordWaypoints(e.data);

          updateShowingCurrent();

          recordsWPObs.disconnect();

          toggleModal();
        };
      }
    }

    /**
     * updateShowingCurrent
     * @description Update the number of records currently showing label
     */
    function updateShowingCurrent() {
      const showingCurrentEl = document.querySelector('[data-showing-current]');
      const showAllBtn = document.querySelector('[data-show-all-records]');
      const numPresentRecords = document.querySelectorAll('.infinite-record-record').length;

      showingCurrentEl.classList.add('item-highlight');
      showingCurrentEl.textContent = numPresentRecords;
      showingCurrentEl.onanimationend = () => {
        showingCurrentEl.classList.remove('item-highlight');
      }

      if (numPresentRecords === NUM_TOTAL_RECORDS) {
        showAllBtn.classList.add('item-fadeout');
        showAllBtn.onanimationend = () => {
          showAllBtn.style.opacity = 0;
        }
        showAllBtn.setAttribute('disabled', true);
      }
    }
  });
</script>

<%= render partial: 'shared/modal_actions' %>
