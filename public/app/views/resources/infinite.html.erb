<a name="main" title="<%= t('internal_links.main') %>"></a>

<div id="main-content" class="row">
  <div class="information col-sm-7">
    <%= render partial: 'shared/idbadge', locals: {:result => @result, :props => { :full => true} } %>
  </div>
  <div class="page_actions col-sm-5 right">
    <%= render partial: 'shared/page_actions', locals: {:record => @result, :title =>  @result.display_string, :url => request.fullpath, :cite => @result.cite } %>
  </div>
</div>

<div class="row">
  <%= render partial: 'shared/breadcrumbs' %>
</div>

<%= render partial: 'resources/resource_alltabs' %>

<style>
  .infinite-scroll-container {
    overflow-y: auto;
    scroll-behavior: smooth;
    height: 600px;
    /*border: 1px solid blue;*/
  }

  .infinite-scroll-container .root {
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  /* increase content area height so bottom-most records can be
     scrolled into view like the others */
  .infinite-scroll-container .waypoint:last-of-type {
    padding-bottom: 550px;
  }

  @keyframes yellowFade {
    from {
      background: yellow;
    }
    to {
      background: transparent;
    }
  }

  @keyframes fadeOut {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }

  .item-highlight {
    animation: yellowFade 2s;
  }
  .item-fadeout {
    animation: fadeOut .5s;
  }

  .spinner-border {
    display: inline-block;
    width: 2rem;
    height: 2rem;
    vertical-align: -.125em;
    border: .25em solid currentColor;
      border-right-color: currentcolor;
    border-right-color: transparent;
    border-radius: 50%;
    -webkit-animation: .75s linear infinite spinner-border;
    animation: .75s linear infinite spinner-border;
  }
  @keyframes spinner-border {
    to { transform: rotate(360deg); }
  }
  .visually-hidden, .visually-hidden-focusable:not(:focus):not(:focus-within) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    padding: 0 !important;
    margin: -1px !important;
    overflow: hidden !important;
    clip: rect(0,0,0,0) !important;
    white-space: nowrap !important;
    border: 0 !important;
  }

  .records-progress-container {
    position: sticky;
    top: 0;
    margin-bottom: 1rem;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-start;
    column-gap: .5rem;
    background: white;
  }
  
  .records-progress-label {
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    font-style: italic;
  }

  .records-progress-button {
    margin-left: -1px;
    cursor: default;
  }

  .waypoint {
    border: 1px solid red;
  }
</style>
<%
  waypoint_size = 20
  num_records = @ordered_records.count
%>
<div class="row">
  <div class="col-sm-9 records-progress-container">
    <p class="records-progress-label">Showing
      <span style="padding: .15rem;" data-showing-current>&nbsp;&nbsp;&nbsp;</span>
      of
      <span style="padding: .15rem;" data-showing-total><%= num_records %></span>
      records
    </p>
    <button class="btn btn-primary records-progress-button" data-show-all-records>Show all records</button>
  </div>
  <div class="col-sm-3">
  </div>
</div>

<div class="row">
  <div
    class="infinite-scroll-container col-sm-9"
    data-waypoint-size="<%= waypoint_size %>"
    data-total-records="<%= num_records %>">
    <div class="root">
      <% @ordered_records.each_slice(waypoint_size).each_with_index do |refs, i| %>
        <div
          class="waypoint"
          data-waypoint-number="<%= i %>"
          data-uris="<%= refs.map {|r| r['ref']}.join(';') %>"
          <%= 'data-observe=waypoint ' if i > 0 %>
        >&nbsp;</div>
      <% end %>
    </div>
  </div>
  <div id="sidebar" class="sidebar sidebar-container col-sm-3 resizable-sidebar infinite-tree-sidebar">
    <% if AppConfig[:pui_search_collection_from_collection_organization] %>
      <%= render partial: 'shared/search_collection_form', :locals => {:resource_uri => @result['uri'], :action_text => t('actions.search_in', :type => t('resource._singular'))} %>
    <% end %>
    <div class="infinite-tree-view largetree-container" id='tree-container'>
      <%
        root_id = @ordered_records[0]['ref'].split('/')[4]
        div_id = "resource_#{root_id}"
        a_href = "#tree::resource_#{root_id}"
        root_title = @ordered_records[0]['display_string']
        root_identifier = " " # TODO: send data via @ordered_records
      %>
      <div class="table root" role="list">
        <div
          class="table-row root-row"
          id="<%= div_id %>"
          role="listitem"
          data-record-number="0"
        >
          <div class="table-cell no-drag-handle"></div>
          <div class="table-cell title">
            <a href="<%= a_href %>" class="record-title">
              <%= "#{root_identifier}: #{root_title}" %>
            </a>
          </div>
        </div>

        <!-- Commence the children -->
        <div role="list" class="table-row-group">

          <!-- no idea why this is here, but fixes a background-color issue that leaks from
              first child to root It likely has to do with the fact that the LargeTree comes from the frontend
              and has drag and drop capability, so they add the drag handle, but the public
              app doesn't have drag and drop, so the drag handle is not needed
          -->
          <div class="table-row waypoint indent-level-1 populated" style="height: 400em;"></div>

          <% all_children = @ordered_records[1..-1] %>
          <% all_children.each_with_index do |ao, i| %>
            <%
              ao_depth = ao['depth']
              ao_id = ao['ref'].split('/')[4]
              ao_div_id = "archival_object_#{ao_id}"
              ao_title = ao['display_string']
              ao_a_href = "#tree::archival_object_#{ao_id}"

              prev_depth = nil
              next_depth = nil
              curr_depth = ao_depth.to_i
              prev_depth = all_children[i-1]['depth'].to_i if i > 0
              next_depth = all_children[i+1]['depth'].to_i if i < all_children.length - 1

              curr_is_first_child = i > 0 && curr_depth > prev_depth
              curr_is_last_child = i < all_children.length - 1 && curr_depth > next_depth

              next_item_is_a_child = all_children[i+1] && (all_children[i+1]['depth'].to_i == ao_depth.to_i + 1)
            %>

            <% if curr_is_first_child %>
              <!-- open a new table-row-group, the last child will close it -->
              <div role="list" class="table-row-group">

                <!-- this div is an unwanted legacy artifact kept for prototyping only
                      should be deleted for production -->
                <div class="table-row waypoint indent-level-<%= ao_depth %> populated" style="height: 400em;"></div>
            <% end %>

            <div
              class="table-row largetree-node indent-level-<%= ao_depth %>"
              role="listitem"
              id="<%= ao_div_id %>"
              data-depth="<%= ao_depth %>"
              data-record-number="<%= i + 1 %>"
              data-is-expanded="false"
            >
              <div class="table-cell drag-handle"></div>
              <div
                class="table-cell title"
                title="<%= ao_title %>"
              >
                <span class="indentor">
                  <button
                    class="expandme"
                    aria-expanded="false"
                    style="visibility: <%= next_item_is_a_child ? 'visible' : 'hidden' %>"
                    aria-hidden="<%= next_item_is_a_child ? 'false' : 'true' %>"
                  >
                    <i class="expandme-icon glyphicon glyphicon-chevron-right"></i>
                    <span class="sr-only"><%= ao_title %></span>
                  </button>
                </span>
                <!--
                  DATA NEEDED to come via @ordered_records:
                  - has_digital_instance
                -->
                <%
                  # create a has_digital_instance variable which is a random boolean
                  # this is just for the prototype, so we can see what it looks like
                  # when there is a digital instance
                  has_digital_instance = [true, false].sample
                %>
                <% if has_digital_instance %>
                  <i
                    class="has_digital_instance fa fa-file-image-o"
                    aria-hidden="true"
                  ></i>
                <% end %>
                <a class="record-title" href="<%= ao_a_href %>"><%= ao_title %></a>
              </div>
            </div>

            <% if curr_is_last_child %>
              <!-- close the necessary number of table row groups -->
              <% (curr_depth - next_depth).times do %>
                </div>
              <% end %>
            <% end %>

          <% end %>
        </div>
      </div>
    </div>
  </div>
</div>

<dialog data-loading-modal>
  <div class="spinner-border" role="status">
    <span class="visually-hidden">Loading...</span>
  </div>
</dialog>

<script>
/* here's what happens:
   1a the sidebar nav "largetree" is fully populated on page load
   1b on page load, the content area is a colleciton of empty containers
     called "waypoints", the number of waypoints = number of records / 20
   2 the first waypoint is populated via ajax manually
   3 at the end of the ajax call the first waypoint's records
     start getting observed to highlight the sidebar nav item corresponding
     to the current record showing, and the remaining empty waypoints
     start getting observed to be populated when they get close to content area
   4 once populated, that waypoint's records start getting observed for sidebar
     nav highlighting
   
   ⚠️ when a sidebar nav item is clicked, the corresponding record is scrolled
     into view _unless_ its corresponding record belongs to an empty waypoint
  
*/
  $(document).ready(function () {
    const WAYPOINT_SIZE = parseInt($('.infinite-scroll-container').data('waypoint-size'), 10);
    const NUM_TOTAL_RECORDS = parseInt($('.infinite-scroll-container').data('total-records'), 10);
    const NUM_TOTAL_WAYPOINTS = Math.ceil(NUM_TOTAL_RECORDS / WAYPOINT_SIZE);
    const scrollContainer = document.querySelector('.infinite-scroll-container');
    const modal = document.querySelector('[data-loading-modal]');

    let isOkToObserve = true;
    let wpObserverIsPopulating = false;

    scrollContainer.addEventListener('scrollend', () => {
      isOkToObserve = true;
    });

    let populateQueue = [];

    const wpQueuePush = new CustomEvent("queuepush");

    // Left off here, the array is getting pushed to, maybe the next steps include
    // populating each wp num in the queue then shifting that wp object out of the queue
    window.addEventListener("queuepush", e => {
      console.log('PUSH!', populateQueue);
    })

    if (!window.location.hash) {
      populateWaypoints([0]);
    } else {
      const treeId = window.location.hash;
      const treeWP = treeIdtoWaypointNumber(treeId)
      const targetWPs = neighborWaypointNums(treeWP)

      populateWaypoints(targetWPs, true, function() {
        scrollToRecord(treeId);
      });
    }

    initWaypointsObserver();

    $('[data-show-all-records]').on('click', () => { populateAllWaypoints(); })

    $('#tree-container').on('click', '.expandme', function(e){
      this.setAttribute('aria-expanded', this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true')
      $(this).find('.expandme-icon').toggleClass('expanded')
      $(this).closest('.largetree-node').attr('data-is-expanded', this.getAttribute('aria-expanded'))
    })

    $('#tree-container').on('click', 'a.record-title', function(e) {
      e.preventDefault();

      window.location.hash = this.href.split('#')[1];

      const recNum = parseInt($(this).closest('[data-record-number]').attr('data-record-number'), 10);
      const wpNum = recordNumberToWaypointNumber(recNum);
      console.log('WPNUM from nav click: ', wpNum);
      let record = document.querySelector(`.infinite-record-record[data-record-number='${recNum}']`);
      if (!record) {
        // LEFT OFF HERE!!! 2023-06-30
        // without setting scroll option to 'instant', the second waypoint is fetched on
        // scroll when the the last record is clicked in the nav. WTF?!
        isOkToObserve = false;

        populateWaypoints(neighborWaypointNums(wpNum), true, function() {
          scrollToRecord(recNum);
        });
      } else {
        record.scrollIntoView({ behavior: "smooth" });
      }
    })

    /**
     * treeIdtoWaypointNumber
     * @description Get the waypoint number of the record with the given treeId
     * @param {string} treeId - treeId of the record, e.g. #tree::archival_object_123
     * @returns {number} - waypoint number
     */
    function treeIdtoWaypointNumber(treeId) {
      const recordTitle = document.querySelector(`.record-title[href='${treeId}']`);
      const recNum = recordTitle.closest('[data-record-number]').getAttribute('data-record-number');

      return recordNumberToWaypointNumber(recNum);
    }

    function recordNumberToWaypointNumber(recNum) {
      if (typeof recNum === 'string') {
        recNum = parseInt(recNum, 10);
      }
      return Math.floor(recNum / WAYPOINT_SIZE);
    }

    function scrollToRecord(recId) {
      let record;
      if (typeof recId === 'number') {
        // recnum
        record = document.querySelector(`.infinite-record-record[data-record-number='${recId}']`);
      } else if (typeof recId === 'string') {
        // hash/treeId
        record = document.querySelector(`${recId.replaceAll(':', '\\:')}`);
      }
      record.scrollIntoView({ behavior: "smooth" });
    }

    /**
     * neighborWaypointNums
     * @description Get the waypoint numbers of the previous and next waypoints
     * @param {number} wpNum - current waypoint number
     * @returns {number[]} - array of consecutive waypoint numbers from least to greatest
     */
    function neighborWaypointNums(wpNum) {
      const result = [];
      // assumes waypoint 2 or greater since waypoint 0 is fetched on page load
      if (wpNum > 1) {
        result.push(wpNum - 1);
      }

      console.log('PREV RESULT = ', result);

      result.push(wpNum);
      console.log('CURR RESULT = ', result);

      if (wpNum < NUM_TOTAL_WAYPOINTS - 1) {
        result.push(wpNum + 1);
      }
      console.log('NEXT RESULT = ', result);

      return result;
    }

    /**
     * toggleModal
     * @description Show spinner loading modal when fetching data
     */
    function toggleModal() {
      if (modal.open) {
        modal.close();
      } else {
        modal.showModal();
      }
    }

    /**
     * populateAllWaypoints
     * @description Populate remaining empty waypoints
     */
    function populateAllWaypoints() {
      const waypointNums = Array.from(document.querySelectorAll('.waypoint:not(.populated)'))
        .map(waypoint => parseInt(waypoint.dataset.waypointNumber, 10));
      
      populateWaypoints(waypointNums);
    }

    /**
     * updateShowingCurrent
     * @description Update the number of records currently showing label
     */
    function updateShowingCurrent() {
      const showingCurrentEl = document.querySelector('[data-showing-current]');
      const showAllBtn = document.querySelector('[data-show-all-records]');
      const numPresentRecords = document.querySelectorAll('.infinite-record-record').length;

      showingCurrentEl.classList.add('item-highlight');
      showingCurrentEl.textContent = numPresentRecords;
      showingCurrentEl.onanimationend = () => {
        showingCurrentEl.classList.remove('item-highlight');
      }

      if (numPresentRecords === NUM_TOTAL_RECORDS) {
        showAllBtn.classList.add('item-fadeout');
        showAllBtn.onanimationend = () => {
          showAllBtn.style.opacity = 0;
        }
        showAllBtn.setAttribute('disabled', true);
      }
    }

    /**
     * populateWaypoints
     * @description Fetch and append records to waypoints
     * @param {number[]} wpNums - array of waypoint numbers to populate
     * @param {[boolean]} handleModal - optional boolean that determines
     * if this function or the calling function should handle the loading modal;
     * defaults to true/this function handles it
     * @param {[function]} callback - optional function to call after
     * each waypoint is populated
     */
    function populateWaypoints(wpNums, handleModal = true, callback = null) {
      console.log('populateWaypoints', wpNums, 'this: ', this);
      wpNums.forEach((wpNum, i) => {
        const waypoint = document.querySelector(`.waypoint[data-waypoint-number='${wpNum}']:not(.populated)`);

        if (!waypoint) {
          return;
        }

        if (handleModal) {
          toggleModal();
        }

        isOkToObserve = false;

        const uris = $(waypoint).data('uris').split(';');
        console.log('waypoint: ', waypoint, 'uris', uris);

        $.ajax('<%= url_for(:action => :show) %>/infinite/waypoints', {
          method: 'GET',
          data: {
            urls: uris,
          },
        }).then(function (records) {
          $(uris).each(function (i, uri) {
            if (records[uri]) {
              const recordNumber = wpNum * WAYPOINT_SIZE + i;
              const type = uri.split('/')[3].replace(/s+$/, "");
              const id = uri.split('/')[4];
              const treeId = `tree::${type}_${id}`;

              $(waypoint).append(
                $('<div class="infinite-record-record" />')
                  .attr('id', treeId)
                  .attr('data-uri', uri)
                  .attr('data-observe', 'record')
                  .attr('data-record-number', recordNumber)
                  .data('record-number', recordNumber)
                  .data('uri', uri)
                  .html(records[uri])
              );
            }
          });
        }).done(function() {
          // actions dependent on ajax completion

          while (populateQueue.length > 0) {
            console.log('QUEUE HAS ITEMS!', populateQueue);
            populateWaypoints([populateQueue.shift()]);
          }

          // Update current number of records showing
          updateShowingCurrent();
          // Watch this waypoint's records created from previous step
          initRecordsObserver(wpNum);
          // Stop observing this waypoint
          waypoint.classList.add('populated');
          waypoint.removeAttribute('data-observe');

          if (callback) {
            callback();
          }

          //resume observing empty waypoints
          // setTimeout(() => {
          //   isOkToObserve = true;
          // }, 0);
          // isOkToObserve = true;

          if (handleModal) {
            toggleModal();
          }
        })
      });
    }

    /**
    * initWaypointsObserver
    * @description Populate empty waypoint containers when they are close
    * to content area
    */
    function initWaypointsObserver() {
      console.log('hello from initWaypointsObserver()!');
      const options = {
        root: document.querySelector('.infinite-scroll-container'),
        rootMargin: '10px 0px 10px 0px',
        threshold: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
      };
      const observer = new IntersectionObserver(intersectionHandler, options);
      const waypoints = document.querySelectorAll('.waypoint[data-observe="waypoint"]');

      waypoints.forEach(waypoint => {
        observer.observe(waypoint);
      });

      function intersectionHandler(entries, observer) {
        entries.forEach((entry, i) => {
          console.log('WPObs! i: ', i, 'entry:', entry, 'isOkToObserve: ', isOkToObserve, 'observer: ', observer);
          const wpNum = parseInt($(entry.target).attr('data-waypoint-number'), 10);

          if (entry.isIntersecting &&
            isOkToObserve &&
            !entry.target.classList.contains('populated')) {
            wpObserverIsPopulating = true;
            toggleModal();

            // wpObserverIsPopulating = true;

            // if (populateQueue.map(item => item.wpNum).indexOf(wpNum) === -1) {
            //   populateQueue.push({wpNum, scrollingDown});
            //   window.dispatchEvent(wpQueuePush);
            // }

            // if (entry.boundingClientRect.top < 0) {
            //   // entered viewport at the top edge, hence scroll direction is up, so
            //   // populate the next two waypoints above
            //   populateWaypoints([wpNum, wpNum - 1], false, () => {
            //     toggleModal();
            //   });
            // } else {
            //   // left viewport at the top edge, hence scroll direction is down, populate
            //   // only the next single waypoint
            //   populateWaypoints([wpNum], false, () => {
            //     toggleModal();
            //   });
            // }

            populateWaypoints([wpNum], false, () => {
              wpObserverIsPopulating = false;
              toggleModal();
            });

            observer.unobserve(entry.target);
          } else if (entry.isIntersecting &&
            !isOkToObserve &&
            !entry.target.classList.contains('populated') && 
            wpObserverIsPopulating) {
              if (populateQueue.indexOf(wpNum) === -1) {
                populateQueue.push(wpNum);
                // window.dispatchEvent(wpQueuePush);
              }
            }
        });
      }
    }

    /**
    * initRecordsObserver
    * @description Observe which record is currently showing at the top
    * of the viewport and highlight the corresponding sidebar nav item
    * wpNum can be number or string
    * @param {(number|string)} wpNum - waypoint number
    */
    function initRecordsObserver(wpNum) {
      const options = {
        root: document.querySelector('.infinite-scroll-container'),
        rootMargin: '-5px 0px -95% 0px' // only the top sliver
      };
      const observer = new IntersectionObserver(intersectionHandler, options);
      const recordSelector = `[data-waypoint-number="${wpNum}"] > [data-observe="record"]`
      const records = document.querySelectorAll(recordSelector);

      records.forEach(record => {
        observer.observe(record);
      });

      function intersectionHandler(entries, observer) {
        entries.forEach((entry, i) => {
          if (entry.isIntersecting) {
            const recNum = entry.target.dataset.recordNumber;
            const prevCurrent = document.querySelector('#tree-container [data-record-number].current')

            if (prevCurrent) {
              prevCurrent.classList.remove('current')
            }

            document
              .querySelector(`#tree-container [data-record-number="${recNum}"]`)
              .classList.add('current')
          }
        });
      }
    }
  })  
</script>

<%= render partial: 'shared/modal_actions' %>
