<a name="main" title="<%= t('internal_links.main') %>"></a>

<div id="main-content" class="row">
  <div class="information col-sm-7">
    <%= render partial: 'shared/idbadge', locals: {:result => @result, :props => { :full => true} } %>
  </div>
  <div class="page_actions col-sm-5 right">
    <%= render partial: 'shared/page_actions', locals: {:record => @result, :title =>  @result.display_string, :url => request.fullpath, :cite => @result.cite } %>
  </div>
</div>

<div class="row">
  <%= render partial: 'shared/breadcrumbs' %>
</div>

<%= render partial: 'resources/resource_alltabs' %>

<style>
  .infinite-scroll-container {
    overflow-y: auto;
    scroll-behavior: smooth;
    height: 600px;
    /*border: 1px solid blue;*/
  }

  .infinite-scroll-container .root {
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  /* increase content area height so bottom-most records can be
     scrolled into view like the others */
  .infinite-scroll-container .waypoint:last-of-type {
    padding-bottom: 550px;
  }

  @keyframes yellowFade {
    from {
      background: yellow;
    }
    to {
      background: transparent;
    }
  }

  @keyframes fadeOut {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }

  .item-highlight {
    animation: yellowFade 2s;
  }
  .item-fadeout {
    animation: fadeOut .5s;
  }

  .spinner-border {
    display: inline-block;
    width: 2rem;
    height: 2rem;
    vertical-align: -.125em;
    border: .25em solid currentColor;
      border-right-color: currentcolor;
    border-right-color: transparent;
    border-radius: 50%;
    -webkit-animation: .75s linear infinite spinner-border;
    animation: .75s linear infinite spinner-border;
  }
  @keyframes spinner-border {
    to { transform: rotate(360deg); }
  }
  .visually-hidden, .visually-hidden-focusable:not(:focus):not(:focus-within) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    padding: 0 !important;
    margin: -1px !important;
    overflow: hidden !important;
    clip: rect(0,0,0,0) !important;
    white-space: nowrap !important;
    border: 0 !important;
  }

  .records-progress-container {
    position: sticky;
    top: 0;
    margin-bottom: 1rem;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-start;
    column-gap: .5rem;
    background: white;
  }
  
  .records-progress-label {
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    font-style: italic;
  }

  .records-progress-button {
    margin-left: -1px;
    cursor: default;
  }

  .waypoint {
    border: 1px solid red;
  }
</style>
<%
  waypoint_size = 20
  num_records = @ordered_records.count
%>
<div class="row">
  <div class="col-sm-9 records-progress-container">
    <p class="records-progress-label">Showing
      <span style="padding: .15rem;" data-showing-current>&nbsp;&nbsp;&nbsp;</span>
      of
      <span style="padding: .15rem;" data-showing-total><%= num_records %></span>
      records
    </p>
    <button class="btn btn-primary records-progress-button" data-show-all-records>Show all records</button>
  </div>
  <div class="col-sm-3">
  </div>
</div>

<div class="row">
  <div
    class="infinite-scroll-container col-sm-9"
    data-waypoint-size="<%= waypoint_size %>"
    data-total-records="<%= num_records %>">
    <div class="root">
      <% @ordered_records.each_slice(waypoint_size).each_with_index do |refs, i| %>
        <div
          class="waypoint"
          data-waypoint-number="<%= i %>"
          data-uris="<%= refs.map {|r| r['ref']}.join(';') %>"
        >&nbsp;</div>
      <% end %>
    </div>
  </div>
  <div id="sidebar" class="sidebar sidebar-container col-sm-3 resizable-sidebar infinite-tree-sidebar">
    <% if AppConfig[:pui_search_collection_from_collection_organization] %>
      <%= render partial: 'shared/search_collection_form', :locals => {:resource_uri => @result['uri'], :action_text => t('actions.search_in', :type => t('resource._singular'))} %>
    <% end %>
    <div class="infinite-tree-view largetree-container" id='tree-container'>
      <%
        root_id = @ordered_records[0]['ref'].split('/')[4]
        div_id = "resource_#{root_id}"
        a_href = "#tree::resource_#{root_id}"
        root_title = @ordered_records[0]['display_string']
        root_identifier = " " # TODO: send data via @ordered_records
      %>
      <div class="table root" role="list">
        <div
          class="table-row root-row"
          id="<%= div_id %>"
          role="listitem"
          data-record-number="0"
        >
          <div class="table-cell no-drag-handle"></div>
          <div class="table-cell title">
            <a href="<%= a_href %>" class="record-title">
              <%= "#{root_identifier}: #{root_title}" %>
            </a>
          </div>
        </div>

        <!-- Commence the children -->
        <div role="list" class="table-row-group">

          <!-- no idea why this is here, but fixes a background-color issue that leaks from
              first child to root It likely has to do with the fact that the LargeTree comes from the frontend
              and has drag and drop capability, so they add the drag handle, but the public
              app doesn't have drag and drop, so the drag handle is not needed
          -->
          <div class="table-row waypoint indent-level-1 populated" style="height: 400em;"></div>

          <% all_children = @ordered_records[1..-1] %>
          <% all_children.each_with_index do |ao, i| %>
            <%
              ao_depth = ao['depth']
              ao_id = ao['ref'].split('/')[4]
              ao_div_id = "archival_object_#{ao_id}"
              ao_title = ao['display_string']
              ao_a_href = "#tree::archival_object_#{ao_id}"

              prev_depth = nil
              next_depth = nil
              curr_depth = ao_depth.to_i
              prev_depth = all_children[i-1]['depth'].to_i if i > 0
              next_depth = all_children[i+1]['depth'].to_i if i < all_children.length - 1

              curr_is_first_child = i > 0 && curr_depth > prev_depth
              curr_is_last_child = i < all_children.length - 1 && curr_depth > next_depth

              next_item_is_a_child = all_children[i+1] && (all_children[i+1]['depth'].to_i == ao_depth.to_i + 1)
            %>

            <% if curr_is_first_child %>
              <!-- open a new table-row-group, the last child will close it -->
              <div role="list" class="table-row-group">

                <!-- this div is an unwanted legacy artifact kept for prototyping only
                      should be deleted for production -->
                <div class="table-row waypoint indent-level-<%= ao_depth %> populated" style="height: 400em;"></div>
            <% end %>

            <div
              class="table-row largetree-node indent-level-<%= ao_depth %>"
              role="listitem"
              id="<%= ao_div_id %>"
              data-depth="<%= ao_depth %>"
              data-record-number="<%= i + 1 %>"
              data-is-expanded="false"
            >
              <div class="table-cell drag-handle"></div>
              <div
                class="table-cell title"
                title="<%= ao_title %>"
              >
                <span class="indentor">
                  <button
                    class="expandme"
                    aria-expanded="false"
                    style="visibility: <%= next_item_is_a_child ? 'visible' : 'hidden' %>"
                    aria-hidden="<%= next_item_is_a_child ? 'false' : 'true' %>"
                  >
                    <i class="expandme-icon glyphicon glyphicon-chevron-right"></i>
                    <span class="sr-only"><%= ao_title %></span>
                  </button>
                </span>
                <!--
                  DATA NEEDED to come via @ordered_records:
                  - has_digital_instance
                -->
                <%
                  # create a has_digital_instance variable which is a random boolean
                  # this is just for the prototype, so we can see what it looks like
                  # when there is a digital instance
                  has_digital_instance = [true, false].sample
                %>
                <% if has_digital_instance %>
                  <i
                    class="has_digital_instance fa fa-file-image-o"
                    aria-hidden="true"
                  ></i>
                <% end %>
                <a class="record-title" href="<%= ao_a_href %>"><%= ao_title %></a>
              </div>
            </div>

            <% if curr_is_last_child %>
              <!-- close the necessary number of table row groups -->
              <% (curr_depth - next_depth).times do %>
                </div>
              <% end %>
            <% end %>

          <% end %>
        </div>
      </div>
    </div>
  </div>
</div>

<dialog data-loading-modal>
  <div class="spinner-border" role="status">
    <span class="visually-hidden">Loading...</span>
  </div>
</dialog>

<script>
/* here's what happens:
   1a the sidebar nav "largetree" is fully populated on page load
   1b on page load, the content area is a colleciton of empty containers
     called "waypoints", the number of waypoints = number of records / 20
   2 the first waypoint is populated via ajax manually
   3 at the end of the ajax call the first waypoint's records
     start getting observed to highlight the sidebar nav item corresponding
     to the current record showing, and the remaining empty waypoints
     start getting observed to be populated when they get close to content area
   4 once populated, that waypoint's records start getting observed for sidebar
     nav highlighting
*/
  $(document).ready(function () {
    const WAYPOINT_SIZE = parseInt($('.infinite-scroll-container').data('waypoint-size'), 10);
    const NUM_TOTAL_RECORDS = parseInt($('.infinite-scroll-container').data('total-records'), 10);
    const NUM_TOTAL_WAYPOINTS = Math.ceil(NUM_TOTAL_RECORDS / WAYPOINT_SIZE);
    const scrollContainer = document.querySelector('.infinite-scroll-container');
    const modal = document.querySelector('[data-loading-modal]');

    function scrollHandler(entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting && isOkToObserve) {
          const target = entry.target;
          const targetRecNum = target.getAttribute('data-record-number');
          const targetWpNum = recordNumberToWaypointNumber(targetRecNum)

          if (target.getAttribute('data-observe-prev-wp')) {
            populateWaypoints([targetWpNum - 1], true, function() {
              target.removeAttribute('data-observe-prev-wp');
            });
            console.log('prev neighbor populated!\ntargetRecNum: ', targetRecNum, '\ntargetWpNum: ', targetWpNum);
          }
          if (target.getAttribute('data-observe-next-wp')) {
            populateWaypoints([targetWpNum + 1], true, function() {
              target.removeAttribute('data-observe-next-wp');
            });
            console.log('next neighbor populated!\ntargetRecNum: ', targetRecNum, '\ntargetWpNum: ', targetWpNum);
          }
        }
      })
    };
    const scrollOpts = {
      root: scrollContainer,
      rootMargin: '-30% 0px -30% 0px'
    };
    const popWpObs = new IntersectionObserver(scrollHandler, scrollOpts);

    let isOkToObserve = true;

    scrollContainer.addEventListener('scrollend', () => {
      isOkToObserve = true;
    });

    if (!window.location.hash) {
      populateWaypoints([0]);
    } else {
      const treeId = window.location.hash;
      const treeWP = treeIdtoWaypointNumber(treeId)
      const targetWPs = neighborWaypointNums(treeWP)

      populateWaypoints(targetWPs, true, function() {
        scrollToRecord(treeId);
      });
    }

    $('[data-show-all-records]').on('click', () => { populateAllWaypoints(); })

    $('#tree-container').on('click', '.expandme', function(e){
      this.setAttribute('aria-expanded', this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true')
      $(this).find('.expandme-icon').toggleClass('expanded')
      $(this).closest('.largetree-node').attr('data-is-expanded', this.getAttribute('aria-expanded'))
    })

    $('#tree-container').on('click', 'a.record-title', function(e) {
      e.preventDefault();

      window.location.hash = this.href.split('#')[1];

      const recNum = parseInt($(this).closest('[data-record-number]').attr('data-record-number'), 10);
      const wpNum = recordNumberToWaypointNumber(recNum);
      const record = document.querySelector(`.infinite-record-record[data-record-number='${recNum}']`);

      if (!record) {
        isOkToObserve = false;

        populateWaypoints(neighborWaypointNums(wpNum), true, function() {
          scrollToRecord(recNum);
        });
      } else {
        record.scrollIntoView({ behavior: "smooth" });
      }
    })

    /**
     * treeIdtoWaypointNumber
     * @description Get the waypoint number of the record with the given treeId
     * @param {string} treeId - treeId of the record, e.g. #tree::archival_object_123
     * @returns {number} - waypoint number
     */
    function treeIdtoWaypointNumber(treeId) {
      const recordTitle = document.querySelector(`.record-title[href='${treeId}']`);
      const recNum = recordTitle.closest('[data-record-number]').getAttribute('data-record-number');

      return recordNumberToWaypointNumber(recNum);
    }

    function recordNumberToWaypointNumber(recNum) {
      if (typeof recNum === 'string') {
        recNum = parseInt(recNum, 10);
      }
      return Math.floor(recNum / WAYPOINT_SIZE);
    }

    function scrollToRecord(recId) {
      let record;
      if (typeof recId === 'number') {
        // recnum
        record = document.querySelector(`.infinite-record-record[data-record-number='${recId}']`);
      } else if (typeof recId === 'string') {
        // hash/treeId
        record = document.querySelector(`${recId.replaceAll(':', '\\:')}`);
      }
      record.scrollIntoView({ behavior: "smooth" });
    }

    /**
     * neighborWaypointNums
     * @description Get the waypoint numbers of the previous and next waypoints
     * @param {number} wpNum - current waypoint number
     * @returns {number[]} - array of consecutive waypoint numbers from least to greatest
     */
    function neighborWaypointNums(wpNum) {
      const result = [];
      // assumes waypoint 2 or greater since waypoint 0 is fetched on page load
      if (wpNum > 1) {
        result.push(wpNum - 1);
      }

      result.push(wpNum);

      if (wpNum < NUM_TOTAL_WAYPOINTS - 1) {
        result.push(wpNum + 1);
      }

      return result;
    }

    /**
     * toggleModal
     * @description Show spinner loading modal when fetching data
     */
    function toggleModal() {
      if (modal.open) {
        modal.close();
      } else {
        modal.showModal();
      }
    }

    /**
     * populateAllWaypoints
     * @description Populate remaining empty waypoints
     */
    function populateAllWaypoints() {
      const waypointNums = Array.from(document.querySelectorAll('.waypoint:not(.populated)'))
        .map(waypoint => parseInt(waypoint.dataset.waypointNumber, 10));
      
      populateWaypoints(waypointNums);
    }

    /**
     * updateShowingCurrent
     * @description Update the number of records currently showing label
     */
    function updateShowingCurrent() {
      const showingCurrentEl = document.querySelector('[data-showing-current]');
      const showAllBtn = document.querySelector('[data-show-all-records]');
      const numPresentRecords = document.querySelectorAll('.infinite-record-record').length;

      showingCurrentEl.classList.add('item-highlight');
      showingCurrentEl.textContent = numPresentRecords;
      showingCurrentEl.onanimationend = () => {
        showingCurrentEl.classList.remove('item-highlight');
      }

      if (numPresentRecords === NUM_TOTAL_RECORDS) {
        showAllBtn.classList.add('item-fadeout');
        showAllBtn.onanimationend = () => {
          showAllBtn.style.opacity = 0;
        }
        showAllBtn.setAttribute('disabled', true);
      }
    }

    /**
     * populateWaypoints
     * @description Fetch and append records to waypoints
     * @param {number[]} wpNums - array of waypoint numbers to populate
     * @param {[boolean]} handleModal - optional boolean that determines
     * if this function or the calling function should handle the loading modal;
     * defaults to true/this function handles it
     * @param {[function]} callback - optional function to call after
     * each waypoint is populated
     */
    function populateWaypoints(wpNums, handleModal = true, callback = null) {
      console.log('populateWaypoints', wpNums, 'this: ', this);
      wpNums.forEach((wpNum, i) => {
        const waypoint = document.querySelector(`.waypoint[data-waypoint-number='${wpNum}']:not(.populated)`);

        if (!waypoint) {
          return;
        }

        if (handleModal) {
          toggleModal();
        }

        isOkToObserve = false;

        const uris = $(waypoint).data('uris').split(';');
        console.log('waypoint: ', waypoint, 'uris', uris);

        $.ajax('<%= url_for(:action => :show) %>/infinite/waypoints', {
          method: 'GET',
          data: {
            urls: uris,
          },
        }).then(function (records) {
          $(uris).each(function (i, uri) {
            if (records[uri]) {
              const recordNumber = wpNum * WAYPOINT_SIZE + i;
              const type = uri.split('/')[3].replace(/s+$/, "");
              const id = uri.split('/')[4];
              const treeId = `tree::${type}_${id}`;

              $(waypoint).append(
                $('<div class="infinite-record-record" />')
                  .attr('id', treeId)
                  .attr('data-uri', uri)
                  .attr('data-observe', 'record')
                  .attr('data-record-number', recordNumber)
                  .data('record-number', recordNumber)
                  .data('uri', uri)
                  .html(records[uri])
              );
            }
          });
        }).done(function() {
          // Actions dependent on ajax completion

          // Update current number of records showing
          updateShowingCurrent();

          // Watch this waypoint's records created from previous step
          initRecordsObserver(wpNum);

          // Watch this waypoint's middle record in order to populate
          // neighboring waypoints
          const targetRecNum = wpNum * WAYPOINT_SIZE + (Math.floor(WAYPOINT_SIZE / 2) - 1);

          function wpHasUnpopPrevNeighbor() {
            return wpNum > 0
              ? !document.querySelector(`.waypoint[data-waypoint-number='${wpNum - 1}']`)
              .classList.contains('populated')
                ? true
                : false
              : false;
          }

          function wpHasUnpopNextNeighbor() {
            return wpNum <= NUM_TOTAL_WAYPOINTS - 2
              ? !document.querySelector(`.waypoint[data-waypoint-number='${wpNum + 1}']`)
              .classList.contains('populated')
                ? true
                : false
              : false;
          }

          if (NUM_TOTAL_WAYPOINTS > 1 && (wpHasUnpopPrevNeighbor() || wpHasUnpopNextNeighbor())) {
            const scrollTarget = document.querySelector(`.infinite-record-record[data-record-number='${targetRecNum}']`);

            if (wpHasUnpopPrevNeighbor()) {
              scrollTarget.setAttribute('data-observe-prev-wp', 'true');
            }
            if (wpHasUnpopNextNeighbor()) {
              scrollTarget.setAttribute('data-observe-next-wp', 'true');
            }

            popWpObs.observe(scrollTarget);
          }

          // Stop observing this waypoint
          waypoint.classList.add('populated');
          waypoint.removeAttribute('data-observe');

          if (callback) {
            console.log('hello from callback in populateWaypoints!')
            callback();
          }

          if (handleModal) {
            toggleModal();
          }
        })
      });
    }

    /**
    * initRecordsObserver
    * @description Observe which record is currently showing at the top
    * of the viewport and highlight the corresponding sidebar nav item
    * wpNum can be number or string
    * @param {(number|string)} wpNum - waypoint number
    */
    function initRecordsObserver(wpNum) {
      // THIS LIKELY NEEDS REFACTORING a la the new waypoint observer,
      // since this observer appears to be used via the approach of creating
      // a new observer each time a waypoint is populated
      const options = {
        root: document.querySelector('.infinite-scroll-container'),
        rootMargin: '-5px 0px -95% 0px' // only the top sliver
      };
      const observer = new IntersectionObserver(intersectionHandler, options);
      const recordSelector = `[data-waypoint-number="${wpNum}"] > [data-observe="record"]`
      const records = document.querySelectorAll(recordSelector);

      records.forEach(record => {
        observer.observe(record);
      });

      function intersectionHandler(entries, observer) {
        entries.forEach((entry, i) => {
          if (entry.isIntersecting) {
            const recNum = entry.target.dataset.recordNumber;
            const prevCurrent = document.querySelector('#tree-container [data-record-number].current')

            if (prevCurrent) {
              prevCurrent.classList.remove('current')
            }

            document
              .querySelector(`#tree-container [data-record-number="${recNum}"]`)
              .classList.add('current')
          }
        });
      }
    }
  })  
</script>

<%= render partial: 'shared/modal_actions' %>
