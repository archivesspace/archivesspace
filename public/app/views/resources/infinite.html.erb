<a name="main" title="<%= t('internal_links.main') %>"></a>

<div id="main-content" class="row">
  <div class="information col-sm-7">
    <%= render partial: 'shared/idbadge', locals: {:result => @result, :props => { :full => true} } %>
  </div>
  <div class="page_actions col-sm-5 right">
    <%= render partial: 'shared/page_actions', locals: {:record => @result, :title =>  @result.display_string, :url => request.fullpath, :cite => @result.cite } %>
  </div>
</div>

<div class="row">
  <%= render partial: 'shared/breadcrumbs' %>
</div>

<%= render partial: 'resources/resource_alltabs' %>

<%
  content_waypoint_size = 20
  sidebar_waypoint_size = 200
  num_records = @ordered_records.count
%>
<div class="row">
  <div class="col-sm-9 records-progress-container">
    <p class="records-progress-label">
      <span style="padding: .15rem;" data-showing-current>&nbsp;&nbsp;&nbsp;</span>
      of
      <span style="padding: .15rem;" data-showing-total><%= num_records %></span>
      records in this collection have loaded onto the page below so far. Scroll down to load more, or click the <strong>&nbsp;Load all records&nbsp;</strong> button.
    </p>
    <button class="btn btn-primary records-progress-button" data-show-all-records>Load all records</button>
  </div>
  <div class="col-sm-3">
  </div>
</div>

<div class="row">
  <div
    class="infinite-scroll-container col-sm-9"
    data-waypoint-size="<%= content_waypoint_size %>"
    data-total-records="<%= num_records %>">
    <div class="root">
      <% @ordered_records.each_slice(content_waypoint_size).each_with_index do |refs, i| %>
        <div
          class="waypoint"
          data-waypoint-number="<%= i %>"
          data-uris="<%= refs.map {|r| r['ref']}.join(';') %>"
        >&nbsp;</div>
      <% end %>
    </div>
  </div>
  <div id="sidebar" class="sidebar sidebar-container col-sm-3 resizable-sidebar infinite-tree-sidebar">
    <% if AppConfig[:pui_search_collection_from_collection_organization] %>
      <%= render partial: 'shared/search_collection_form', :locals => {:resource_uri => @result['uri'], :action_text => t('actions.search_in', :type => t('resource._singular'))} %>
    <% end %>

    <div
      class="infinite-tree-view largetree-container"
      id="tree-container"
      data-waypoint-size="<%= sidebar_waypoint_size %>"
      data-repo-id="<%= @result['uri'].split('/')[2] %>"
      data-resource-id="<%= @result['uri'].split('/')[4] %>"
    >
      <!-- load the tree root's first waypoint -->
      <%
        root_id = @nav_tree_root['uri'].split('/')[4]
        div_id = "resource_#{root_id}"
        a_href = "#tree::resource_#{root_id}"
        root_title = @nav_tree_root['title']
        root_identifier = @nav_tree_root['identifier']
      %>

    </div>
  </div>
</div>

<dialog data-loading-modal>
  <div class="spinner-border" role="status">
    <span class="visually-hidden">Loading...</span>
  </div>
</dialog>

<template id="node-row-template">
  <div class="table-row largetree-node" role="listitem">
    <div class="table-cell title">
      <span class="indentor">
        <button class="expandme" aria-expanded="false">
          <i class="expandme-icon glyphicon glyphicon-chevron-right"></i>
          <span class="sr-only"></span>
        </button>
      </span>
      <a class="record-title"></a>
    </div>
  </div>
</template>

<script>
  $(document).ready(function () {
    // nav arbitrary scroll

    const NAV_WAYPOINT_SIZE = '<%= sidebar_waypoint_size %>';
    const repoId = '<%= @result['uri'].split('/')[2] %>';
    const resourceId = '<%= @result['uri'].split('/')[4] %>';
    const rootNodeDivId = `resource_${resourceId}`;
    const treeBaseUri = '<%= url_for(:action => :show) %>/tree';
    const treeRootUri = `${treeBaseUri}/root`;
    const treeNodeUri = `${treeBaseUri}/node`;
    const treeWaypointUri = `${treeBaseUri}/waypoint`;

    const treeContainer = document.querySelector('#tree-container');

    const treeObsOpts = {
      root: treeContainer,
      rootMargin: '-30% 0px -30% 0px'
    };
    const treeWpObs = new IntersectionObserver(treeObsHandler, treeObsOpts);

    fetchRootNode()
      .done(rootNode => {
        console.log('rootNode: ', rootNode);
        const aHref = `#tree::resource_${resourceId}`;
        const title = rootNode.title;
        const identifier = rootNode.identifier;
        const firstWPData = rootNode.precomputed_waypoints[""][0];

        const tableRootFrag = new DocumentFragment();

        const tableRoot = document.createElement('div');
        tableRoot.setAttribute('role', 'list');
        tableRoot.className = 'table root';

        tableRoot.appendChild(rootRowMarkup(identifier, title));
        tableRoot.appendChild(rootNodeWaypointsScaffold(
          rootNodeDivId,
          1,
          rootNode.waypoints
        ));

        __populateWaypoint(
          tableRoot.querySelector('.table-row-group'),
          firstWPData,
          1,
          rootNode.waypoints > 1
        );

        tableRootFrag.appendChild(tableRoot);

        treeContainer.appendChild(tableRootFrag);

        if (rootNode.waypoints > 1) {
          // now that the above work has been added to the live DOM, start observing
          // the middle node in order to populate the next empty waypoint
          const obsSelector = `[data-parent-id="${rootNodeDivId}"][data-waypoint-number="0"] > [data-observe-next-wp]`;
          const obsTarget = document.querySelector(obsSelector);

          treeWpObs.observe(obsTarget);
        }
      })
      .fail(err => {
        console.log('root node fetch error: ', err);
      });

    /**
     * __populateWaypoint
     * @description - Populate the first waypoint of a newly created
     * rootNodeWaypointsScaffold
     * @param {HTMLElement} waypoint - the empty waypoint to populate
     * @param {array} nodes - array of node objects to populate the waypoint with
     * @param {number} level - level of the waypoint
     * @param {boolean} hasNextEmptyWP - whether or not there is a next empty waypoint
     */
    function __populateWaypoint(waypoint, nodes, level, hasNextEmptyWP) {
      const waypointMarker = waypoint.querySelector('.waypoint');
      const nodeRowsFrag = new DocumentFragment();

      waypointMarker.classList.add('populated');

      nodes.forEach((node, i) => {
        // observe the middle node if there is a next empty waypoint
        const observeThisNode = (i == Math.floor(NAV_WAYPOINT_SIZE / 2) - 1 && hasNextEmptyWP);
        const markupArgs = [node, level, observeThisNode];

        if (observeThisNode) {
          const nodeParentId = waypoint.getAttribute('data-parent-id');
          const nodeWpNum = parseInt(waypoint.getAttribute('data-waypoint-number'), 10);
          
          markupArgs.push(nodeParentId, nodeWpNum + 1);
        }

        nodeRowsFrag.appendChild(nodeRowMarkup(...markupArgs));
      });

      waypoint.appendChild(nodeRowsFrag);
    }

    /**
     * nodeWaypointsScaffold
     * @description - Append the empty set of waypoint containers belonging to a node
     * after the node element; append elements manually because insertAdjacentElement()
     * @param {number} nodeId - div id of the parent node whose waypoints
     * are being scaffolded
     * @param {number} level - level of the waypoints
     * @param {number} numWPs - number of waypoints to create
     */
    function nodeWaypointsScaffold(nodeId, level, numWPs) {
      for (let i = 0; i < numWPs; i++) {
        const prevSibling = i === 0
          ? document.querySelector(`#${nodeId}`)
          : document.querySelector(`[data-parent-id="${nodeId}"][data-waypoint-number="${i - 1}"]`);

        const tableRowGroup = document.createElement('div');
        tableRowGroup.className = 'table-row-group';
        tableRowGroup.setAttribute('data-parent-id', nodeId);
        tableRowGroup.setAttribute('data-waypoint-number', i);
        tableRowGroup.setAttribute('data-waypoint-level', level);
        tableRowGroup.setAttribute('role', 'list');

        const tableRow = document.createElement('div');
        tableRow.className = `table-row waypoint indent-level-${level}`;

        prevSibling.insertAdjacentElement('afterend', tableRowGroup);

        const liveTableRowGroup = document.querySelector(
          `[data-parent-id="${nodeId}"][data-waypoint-number="${i}"]`
        );

        liveTableRowGroup.appendChild(tableRow);
      }
    }

    /**
     * rootNodeWaypointsScaffold
     * @description - Build the waypoints of a node and populate the first waypoint
     * @param {number} nodeId - div id of the parent node whose waypoints
     * are being scaffolded
     * @param {number} level - level of the waypoints
     * @param {number} numWPs - number of waypoints to create
     * @returns {DocumentFragment} - DocumentFragment containing the waypoint
     */
    function rootNodeWaypointsScaffold(nodeId, level, numWPs) {
      const nodeWaypointsFrag = new DocumentFragment();

      for (let i = 0; i < numWPs; i++) {
        const tableRowGroup = document.createElement('div');
        tableRowGroup.className = 'table-row-group';
        tableRowGroup.setAttribute('data-parent-id', nodeId);
        tableRowGroup.setAttribute('data-waypoint-number', i);
        tableRowGroup.setAttribute('data-waypoint-level', level);
        tableRowGroup.setAttribute('role', 'list');

        const tableRow = document.createElement('div');
        tableRow.className = `table-row waypoint indent-level-${level}`;

        tableRowGroup.appendChild(tableRow);

        nodeWaypointsFrag.appendChild(tableRowGroup);
      }

      return nodeWaypointsFrag;
    }

    /**
     * nodeRowMarkup
     * @description - Build the markup for a node row
     * @param {Object} node - node data
     * @param {number} level - indent level of the node
     * @param {boolean} shouldObserve - whether or not to observe the node
     * in order to populate the next empty waypoint
     * @param {number} [parentId=null] - optional ID of the node's parent; if null
     * then parent is assumed to be the root resource
     * @param {number} [offset=null] - optional offset of the next waypoint to
     * populate; required if `shouldObserve` is true
     * @returns {DocumentFragment} - DocumentFragment containing the node row
     */
    function nodeRowMarkup(node, level, shouldObserve, parentId = null, offset = null) {
      const aoId = node.uri.split('/')[4];
      const divId = `archival_object_${aoId}`;
      const aoTitle = node.title;
      const aHref = `#tree::${divId}`;

      const nodeRowFrag = new DocumentFragment();

      const nodeRow = document.querySelector('#node-row-template').content.cloneNode(true);

      nodeRow.querySelector('.table-row').id = divId;
      nodeRow.querySelector('.table-row').classList.add(`indent-level-${level}`);

      if (shouldObserve) {
        const nodeParam = parentId.startsWith('resource')
          ? ''
          : `/repositories/${repoId}/archival_objects/${parentId.split('_')[2]}`;

        nodeRow.querySelector('.table-row').setAttribute('data-observe-next-wp', true);
        nodeRow.querySelector('.table-row').setAttribute('data-observe-node', nodeParam);
        nodeRow.querySelector('.table-row').setAttribute('data-observe-offset', offset);
      }

      nodeRow.querySelector('.table-cell').setAttribute('title', aoTitle);

      if (node.child_count == 0) {
        nodeRow.querySelector('.expandme').style.visibility = 'hidden';
        nodeRow.querySelector('.expandme').setAttribute('aria-hidden', 'true');
      } else if (node.child_count > 0) {
        nodeRow.querySelector('.table-row').setAttribute('data-has-expanded', false)
        nodeRow.querySelector('.table-row').setAttribute('data-is-expanded', false)
        nodeRow.querySelector('.expandme').setAttribute('aria-expanded', 'false');
      }

      nodeRow.querySelector('.sr-only').textContent = aoTitle;

      if (node.has_digital_instance) {
        const iconHtml = `<i class="has_digital_instance fa fa-file-image-o" aria-hidden="true"></i>`;

        nodeRow.querySelector('.record-title').insertAdjacentHTML('beforebegin', iconHtml);
      }

      nodeRow.querySelector('.record-title').setAttribute('href', aHref);
      nodeRow.querySelector('.record-title').textContent = aoTitle;

      nodeRowFrag.appendChild(nodeRow);

      return nodeRowFrag;
    }

    /**
     * rootRowMarkup
     * @description Append the root row to the tree container
     * @param {string} identifier - identifier of the root node
     * @param {string} title - title of the root node
     * @returns {DocumentFragment} - DocumentFragment containing the root row
     */
    function rootRowMarkup(identifier, title) {
      const rootRowFrag = new DocumentFragment();

      const rootRow = document.createElement('div');
      rootRow.setAttribute('role', 'listitem');
      rootRow.id = `resource_${resourceId}`
      rootRow.className = 'table-row root-row';

      const rootTitleCell = document.createElement('div');
      rootTitleCell.className = 'table-cell title';

      const rootTitleLink = document.createElement('a');
      rootTitleLink.href = `#tree::resource_${resourceId}`;
      rootTitleLink.className = 'record-title';
      rootTitleLink.innerHTML = `${identifier}: ${title}`;

      rootTitleCell.appendChild(rootTitleLink);
      rootRow.appendChild(rootTitleCell);
      rootRowFrag.appendChild(rootRow);

      return rootRowFrag;
    }

    /**
     * fetchWaypoint
     * @description Fetch the next waypoint of the given node
     * @param {Object} params - object of params for the ajax call with the signature:
     * @param {string} params.node - node url param in the form of '' or '/repositories/X/archival_objects/Y'
     * @param {number} params.offset - offset url param
     * @returns {Promise} - Promise that resolves with the waypoint object
     */
    function fetchWaypoint(params) {
      return $.ajax(treeWaypointUri, {
        method: 'GET',
        dataType: 'json',
        data: params
      });
    }

    /**
     * fetchNode
     * @description Fetch the tree of the node with the given id
     * @param {number} nodeId - id of the node, ie: 18028
     * @returns {Promise} - Promise that resolves with the node object
     */
    function fetchNode(nodeId) {
      return $.ajax(treeNodeUri, {
        method: 'GET',
        dataType: 'json',
        data: {
          node: `/repositories/${repoId}/archival_objects/${nodeId}`
        }
      });
    }

    /**
     * fetchRootNode
     * @description Fetch the root node of the tree
     * @returns {Promise} - Promise that resolves with the root node object
     */
    function fetchRootNode() {
      return $.ajax(treeRootUri, { method: "GET", dataType: 'json' });
    }

    function treeObsHandler(entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const thisWaypoint = entry.target.closest('.table-row-group');

          if (!nextSiblingIsNextWaypoint(thisWaypoint)) {
            return;
          }

          const nextWaypoint = thisWaypoint.nextElementSibling;
          const node = entry.target.getAttribute('data-observe-node');
          const offset = entry.target.getAttribute('data-observe-offset');
          const level = thisWaypoint.getAttribute('data-waypoint-level');

          fetchWaypoint({ node, offset})
            .done((nodes) => {
              const nextWPHasNextWP = nextSiblingIsNextWaypoint(nextWaypoint);

              __populateWaypoint(nextWaypoint, nodes, level, nextWPHasNextWP);

              if (nextWPHasNextWP) {
                const nextWPTarget = nextWaypoint.querySelector('[data-observe-next-wp="true"]');

                observer.observe(nextWPTarget);
              }

              entry.target.removeAttribute('data-observe-next-wp');
              entry.target.removeAttribute('data-observe-node');
              entry.target.removeAttribute('data-observe-offset');

              observer.unobserve(entry.target);
            })
        }
      })
    };

    /**
     * nextSiblingIsNextWaypoint
     * @description Determine if the next sibling of the given waypoint is
     * the next empty waypoint of the same parent
     * @param {HTMLElement} waypoint - waypoint to check
     * @returns {boolean} - true if the next sibling is the next empty waypoint
     * of the same parent
     */
    function nextSiblingIsNextWaypoint(waypoint) {
      const nextSibling = waypoint.nextElementSibling;

      if (!nextSibling) {
        return false;
      }

      const thisWpParent = waypoint.getAttribute('data-parent-id');
      const thisWpNum = parseInt(waypoint.getAttribute('data-waypoint-number'), 10);

      const nextSiblingParent = nextSibling.getAttribute('data-parent-id');
      const nextSiblingWpNum = parseInt(nextSibling.getAttribute('data-waypoint-number'), 10);
      const nextSiblingFirstChild = nextSibling.firstElementChild;

      return nextSiblingParent == thisWpParent &&
        nextSiblingWpNum == thisWpNum + 1 &&
        nextSiblingFirstChild.classList.contains('waypoint') &&
        !nextSiblingFirstChild.classList.contains('populated');
    };

    $('#tree-container').on('click', '.expandme', function(e){
      this.setAttribute('aria-expanded', this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true');
      $(this).closest('.largetree-node').attr('data-is-expanded', this.getAttribute('aria-expanded'));
      $(this).find('.expandme-icon').toggleClass('expanded');

      if (this.closest('.largetree-node').getAttribute('data-has-expanded') === 'false') {
        const nodeDivId = this.closest('.largetree-node').id;

        initNodeChildren(nodeDivId);

        this.closest('.largetree-node').setAttribute('data-has-expanded', true);
      }
    });

    /**
     * initNodeChildren
     * @description Build a parent node's waypoint scaffold and populate the first
     * waypoint
     * @param {string} nodeDivId - div#id of the parent node, ie: 'archival_object_18028'
     */
    function initNodeChildren(nodeDivId) {
      const parentNode = document.querySelector(`#${nodeDivId}`);
      const nodeId = nodeDivId.split('_')[2];
      const nodeLevel = parseInt(document
        .querySelector(`#${nodeDivId}`)
        .closest('.table-row-group')
        .getAttribute('data-waypoint-level'), 10);

      fetchNode(nodeId)
        .done((node) => {
          const nodeWpCount = node.waypoints;
          const nodeUri = `/repositories/${repoId}/archival_objects/${nodeId}`;

          nodeWaypointsScaffold(nodeDivId, nodeLevel + 1, nodeWpCount);

          const firstWP = document.querySelector(`[data-parent-id="${nodeDivId}"][data-waypoint-number="0"]`);

          __populateWaypoint(
            firstWP,
            node.precomputed_waypoints[nodeUri][0],
            nodeLevel + 1,
            nodeWpCount > 1
          );

          if (nodeWpCount > 1) {
            treeWpObs.observe(firstWP.querySelector('[data-observe-next-wp]'));
          }
        });
    }

    /**
     * collapseParentNode
     * @description Hide the children of the given parent node
     * @param {string} parentId - id of the parent node
     */
    function collapseParentNode(parentId) {}

    // content arbitrary scroll
    const WAYPOINT_SIZE = parseInt($('.infinite-scroll-container').data('waypoint-size'), 10);
    const NUM_TOTAL_RECORDS = parseInt($('.infinite-scroll-container').data('total-records'), 10);
    const NUM_TOTAL_WAYPOINTS = Math.ceil(NUM_TOTAL_RECORDS / WAYPOINT_SIZE);
    const scrollContainer = document.querySelector('.infinite-scroll-container');
    const modal = document.querySelector('[data-loading-modal]');

    function scrollHandler(entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting && isOkToObserve) {
          const target = entry.target;
          const targetRecNum = target.getAttribute('data-record-number');
          const targetWpNum = recordNumberToWaypointNumber(targetRecNum)

          if (target.getAttribute('data-observe-prev-wp')) {
            populateWaypoints([targetWpNum - 1], true, function() {
              target.removeAttribute('data-observe-prev-wp');
            });
            console.log('prev neighbor populated!\ntargetRecNum: ', targetRecNum, '\ntargetWpNum: ', targetWpNum);
          }
          if (target.getAttribute('data-observe-next-wp')) {
            populateWaypoints([targetWpNum + 1], true, function() {
              target.removeAttribute('data-observe-next-wp');
            });
            console.log('next neighbor populated!\ntargetRecNum: ', targetRecNum, '\ntargetWpNum: ', targetWpNum);
          }
        }
      })
    };
    const scrollOpts = {
      root: scrollContainer,
      rootMargin: '-30% 0px -30% 0px'
    };
    const popWpObs = new IntersectionObserver(scrollHandler, scrollOpts);

    let isOkToObserve = true;

    scrollContainer.addEventListener('scrollend', () => {
      isOkToObserve = true;
    });

    if (!window.location.hash) {
      populateWaypoints([0]);
    } else {
      const treeId = window.location.hash;
      const treeWP = treeIdtoWaypointNumber(treeId)
      const targetWPs = neighborWaypointNums(treeWP)

      populateWaypoints(targetWPs, true, function() {
        scrollToRecord(treeId);
      });
    }

    $('[data-show-all-records]').on('click', () => { populateAllWaypoints(); })

    // $('#tree-container').on('click', '.expandme', function(e){
    //   this.setAttribute('aria-expanded', this.getAttribute('aria-expanded') === 'true' ? 'false' : 'true')
    //   $(this).find('.expandme-icon').toggleClass('expanded')
    //   $(this).closest('.largetree-node').attr('data-is-expanded', this.getAttribute('aria-expanded'))
    // })

    $('#tree-container').on('click', 'a.record-title', function(e) {
      e.preventDefault();

      window.location.hash = this.href.split('#')[1];

      const recNum = parseInt($(this).closest('[data-record-number]').attr('data-record-number'), 10);
      const wpNum = recordNumberToWaypointNumber(recNum);
      const record = document.querySelector(`.infinite-record-record[data-record-number='${recNum}']`);

      if (!record) {
        isOkToObserve = false;

        populateWaypoints(neighborWaypointNums(wpNum), true, function() {
          scrollToRecord(recNum);
        });
      } else {
        record.scrollIntoView({ behavior: "smooth" });
      }
    })

    /**
     * treeIdtoWaypointNumber
     * @description Get the waypoint number of the record with the given treeId
     * @param {string} treeId - treeId of the record, e.g. #tree::archival_object_123
     * @returns {number} - waypoint number
     */
    function treeIdtoWaypointNumber(treeId) {
      const recordTitle = document.querySelector(`.record-title[href='${treeId}']`);
      const recNum = recordTitle.closest('[data-record-number]').getAttribute('data-record-number');

      return recordNumberToWaypointNumber(recNum);
    }

    function recordNumberToWaypointNumber(recNum) {
      if (typeof recNum === 'string') {
        recNum = parseInt(recNum, 10);
      }
      return Math.floor(recNum / WAYPOINT_SIZE);
    }

    function scrollToRecord(recId) {
      let record;
      if (typeof recId === 'number') {
        // recnum
        record = document.querySelector(`.infinite-record-record[data-record-number='${recId}']`);
      } else if (typeof recId === 'string') {
        // hash/treeId
        record = document.querySelector(`${recId.replaceAll(':', '\\:')}`);
      }
      record.scrollIntoView({ behavior: "smooth" });
    }

    /**
     * neighborWaypointNums
     * @description Get the waypoint numbers of the previous and next waypoints
     * @param {number} wpNum - current waypoint number
     * @returns {number[]} - array of consecutive waypoint numbers from least to greatest
     */
    function neighborWaypointNums(wpNum) {
      const result = [];
      // assumes waypoint 2 or greater since waypoint 0 is fetched on page load
      if (wpNum > 1) {
        result.push(wpNum - 1);
      }

      result.push(wpNum);

      if (wpNum < NUM_TOTAL_WAYPOINTS - 1) {
        result.push(wpNum + 1);
      }

      return result;
    }

    /**
     * toggleModal
     * @description Show spinner loading modal when fetching data
     */
    function toggleModal() {
      if (modal.open) {
        modal.close();
      } else {
        modal.showModal();
      }
    }

    /**
     * populateAllWaypoints
     * @description Populate remaining empty waypoints
     */
    function populateAllWaypoints() {
      const waypointNums = Array.from(document.querySelectorAll('.waypoint:not(.populated)'))
        .map(waypoint => parseInt(waypoint.dataset.waypointNumber, 10));
      
      populateWaypoints(waypointNums);
    }

    /**
     * updateShowingCurrent
     * @description Update the number of records currently showing label
     */
    function updateShowingCurrent() {
      const showingCurrentEl = document.querySelector('[data-showing-current]');
      const showAllBtn = document.querySelector('[data-show-all-records]');
      const numPresentRecords = document.querySelectorAll('.infinite-record-record').length;

      showingCurrentEl.classList.add('item-highlight');
      showingCurrentEl.textContent = numPresentRecords;
      showingCurrentEl.onanimationend = () => {
        showingCurrentEl.classList.remove('item-highlight');
      }

      if (numPresentRecords === NUM_TOTAL_RECORDS) {
        showAllBtn.classList.add('item-fadeout');
        showAllBtn.onanimationend = () => {
          showAllBtn.style.opacity = 0;
        }
        showAllBtn.setAttribute('disabled', true);
      }
    }

    /**
     * populateWaypoints
     * @description Fetch and append records to waypoints
     * @param {number[]} wpNums - array of waypoint numbers to populate
     * @param {[boolean]} handleModal - optional boolean that determines
     * if this function or the calling function should handle the loading modal;
     * defaults to true/this function handles it
     * @param {[function]} callback - optional function to call after
     * each waypoint is populated
     */
    function populateWaypoints(wpNums, handleModal = true, callback = null) {
      console.log('populateWaypoints', wpNums, 'this: ', this);
      wpNums.forEach((wpNum, i) => {
        const waypoint = document.querySelector(`.waypoint[data-waypoint-number='${wpNum}']:not(.populated)`);

        if (!waypoint) {
          return;
        }

        if (handleModal) {
          toggleModal();
        }

        isOkToObserve = false;

        const uris = $(waypoint).data('uris').split(';');
        console.log('waypoint: ', waypoint, 'uris', uris);

        $.ajax('<%= url_for(:action => :show) %>/infinite/waypoints', {
          method: 'GET',
          data: {
            urls: uris,
          },
        }).then(function (records) {
          $(uris).each(function (i, uri) {
            if (records[uri]) {
              const recordNumber = wpNum * WAYPOINT_SIZE + i;
              const type = uri.split('/')[3].replace(/s+$/, "");
              const id = uri.split('/')[4];
              const treeId = `tree::${type}_${id}`;

              $(waypoint).append(
                $('<div class="infinite-record-record" />')
                  .attr('id', treeId)
                  .attr('data-uri', uri)
                  .attr('data-observe', 'record')
                  .attr('data-record-number', recordNumber)
                  .data('record-number', recordNumber)
                  .data('uri', uri)
                  .html(records[uri])
              );
            }
          });
        }).done(function() {
          // Actions dependent on ajax completion

          // Update current number of records showing
          updateShowingCurrent();

          // Watch this waypoint's records created from previous step
          initRecordsObserver(wpNum);

          // Watch this waypoint's middle record in order to populate
          // neighboring waypoints
          const targetRecNum = wpNum * WAYPOINT_SIZE + (Math.floor(WAYPOINT_SIZE / 2) - 1);

          function wpHasUnpopPrevNeighbor() {
            return wpNum > 0
              ? !document.querySelector(`.waypoint[data-waypoint-number='${wpNum - 1}']`)
              .classList.contains('populated')
                ? true
                : false
              : false;
          }

          function wpHasUnpopNextNeighbor() {
            return wpNum <= NUM_TOTAL_WAYPOINTS - 2
              ? !document.querySelector(`.waypoint[data-waypoint-number='${wpNum + 1}']`)
              .classList.contains('populated')
                ? true
                : false
              : false;
          }

          if (NUM_TOTAL_WAYPOINTS > 1 && (wpHasUnpopPrevNeighbor() || wpHasUnpopNextNeighbor())) {
            const scrollTarget = document.querySelector(`.infinite-record-record[data-record-number='${targetRecNum}']`);

            if (wpHasUnpopPrevNeighbor()) {
              scrollTarget.setAttribute('data-observe-prev-wp', 'true');
            }
            if (wpHasUnpopNextNeighbor()) {
              scrollTarget.setAttribute('data-observe-next-wp', 'true');
            }

            popWpObs.observe(scrollTarget);
          }

          // Stop observing this waypoint
          waypoint.classList.add('populated');
          waypoint.removeAttribute('data-observe');

          if (callback) {
            console.log('hello from callback in populateWaypoints!')
            callback();
          }

          if (handleModal) {
            toggleModal();
          }
        })
      });
    }

    /**
     * initRecordsObserver
     * @description Observe which record is currently showing at the top
     * of the viewport and highlight the corresponding sidebar nav item
     * wpNum can be number or string
     * @param {(number|string)} wpNum - waypoint number
     */
    function initRecordsObserver(wpNum) {
      // THIS LIKELY NEEDS REFACTORING a la the new waypoint observer,
      // since this observer appears to be used via the approach of creating
      // a new observer each time a waypoint is populated
      const options = {
        root: document.querySelector('.infinite-scroll-container'),
        rootMargin: '-5px 0px -95% 0px' // only the top sliver
      };
      const observer = new IntersectionObserver(intersectionHandler, options);
      const recordSelector = `[data-waypoint-number="${wpNum}"] > [data-observe="record"]`
      const records = document.querySelectorAll(recordSelector);

      records.forEach(record => {
        observer.observe(record);
      });

      function intersectionHandler(entries, observer) {
        entries.forEach((entry, i) => {
          if (entry.isIntersecting) {
            const recNum = entry.target.dataset.recordNumber;
            const prevCurrent = document.querySelector('#tree-container [data-record-number].current')

            if (prevCurrent) {
              prevCurrent.classList.remove('current')
            }

            document
              .querySelector(`#tree-container [data-record-number="${recNum}"]`)
              .classList.add('current')
          }
        });
      }
    }
  });
</script>

<%= render partial: 'shared/modal_actions' %>
